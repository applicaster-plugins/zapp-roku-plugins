import "pkg:/source/lib/ViewUtils.bs"
import "pkg:/source/roku_modules/maestro/core/Utils.brs"
import "pkg:/source/UIBuilder/view/ComponentVM.bs"
import "pkg:/source/UIBuilder/view/ScreenVM.bs"
import "pkg:/source/zapp-controls/CollectionRowUtils.bs"
import "pkg:/source/mixin/KeyboardDialogMixin.bs"
import "pkg:/source/roku_group_component/GroupComponentVM.bs"
import "pkg:/source/quick-brick-smart-component/SmartComponentVM.bs"
import "pkg:/source/lib/GeneralScreenUtils.bs"

class TVFullScreenSearchVM extends zapp.uib.ScreenVM

  ' screen container
  public currentScreen = invalid
  public isScreenContainerVisible = false

  'menu styles
  public menuButtons = []
  public menuStyle = {}
  public jumpToIndex = -1
  public isShowingScreenOnFocus = true
  public layoutDirection = "horiz"
  public isFilterVisible = false
  public jumpSelectToIndex = 0
  public buttonSpacing = 5
  public buttonTranslation = [0, 0]
  public buttonContainerTranslation = [0, 0]
  public labelXOffset = 0
  public isButtonDynamic = false
  public isDynamicGroupSize = false

  'keyboard styles
  public keyboardItem = invalid
  public searchText = ""
  public searchTextInput = ""

  'grid styles
  public isGridVisible = false
  public components = []
  public moveableComponents = []
  public componentIndex = 0
  public needsRecalculating = false
  public componentYOffsets = []

  private results = invalid
  private isFirstLoadComplete = false
  private fallbackScreen = invalid
  private searchDelayTask = invalid
  private loadMoreTask = invalid
  private minCharacters = 3
  private isShowingContent = false
  private searchHaveResults = false
  private itemWasSelected = false
  private searchData = ""
  private filterData = ""
  private nameOfParentScreen = ""

  private localizations = invalid
  private isSearchFilterEnabled = false
  private textTransform = "uppercase"
  private focusedFilterIndex = 0
  private savedIndex = 0
  private selectedFilterIndex = 0
  private isFilterFocusable = false
  private searchFlowLayout = invalid
  private backgroundBorderPoster = invalid
  private backgroundPoster = invalid
  private buttonMenu = invalid
  private tabComponentPaddings = invalid
  private tabIsLoaded = false

  'keyboard dialog mixin
  private showKeyboardDialog = zapp.keyboardDialogMixin.showKeyboardDialog
  private _onKeyboardDialogButtonSelected = zapp.keyboardDialogMixin.onKeyboardDialogButtonSelected
  private _closeKeyboardDialog = zapp.keyboardDialogMixin.closeKeyboardDialog
  private setTextFromKeyboard = zapp.keyboardDialogMixin.setTextFromKeyboard

  ' DynamicContainer Mixin
  private uiBuilderFactory = invalid
  private currentComponents = []
  private newLazyComponents = []
  private newLazyMoveableComponents = []
  private newLazyComponentsYOffsets = []
  private isLazyLoading = false
  private lazyLoadingBatchSize = 5
  private batchSize = 15
  private isRefreshNeeded = true
  private uiComponents = []
  private errorComponentIndex = []
  private screenId = ""

  @inject("analyticsManager")
  private analytics

  public function new(riversJson)
    super(riversJson, "TVFullScreenSearchVM")
    riversJson = zapp.platformAlignmentUtils.transformTVSearchToRoku(riversJson)
    m.searchFlowLayout = m.getMField("searchFlowLayout")
    m.backgroundBorderPoster = m.getMField("backgroundBorderPoster")
    m.backgroundPoster = m.getMField("backgroundPoster")
    m.buttonMenu = m.getMField("menu")
    m.uiBuilderFactory = zapp.uib.mixin.getComponentFactory()

    m.focusId = "keyboard"
    m.setScreenLocalizations(riversJson.localizations)
    m.processStyles(riversJson.styles)
    m.processTabStyles(riversJson.styles)
    m.setGridVisible(false)
    m.setScreenContainerVisible(true)

    m.fallbackScreen = asString(riversJson.general.fallback)
    m.isSearchFilterEnabled = zapp.viewUtils.getUIBBool(riversJson.general, "enable_search_filters", false)

    if m.isSearchFilterEnabled
      m.searchData = asAA(riversJson.ui_components[0].data, riversJson.data)
      m.filterData = asAA(riversJson.data)
    else
      m.searchData = asAA(riversJson.data)
      m.filterData = m.searchData
    end if
    m.setFocusId("keyboard")
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ DynamicContainer Mixin
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public override function createContent()
    m.includeAdditionalComponentIfNeeded()
  end function

  private function includeAdditionalComponentIfNeeded(index = 0, refresh = true) as void
    riversCount = m.riversJson.ui_components.count()
    proceedCreating = false

    if index >= riversCount
      m.isLoading = false
      return
    end if

    if m.newLazyComponents.count() > 0
      batchSize = m.lazyLoadingBatchSize
      m.isLazyLoading = true
    else
      batchSize = m.batchSize
    end if

    if refresh
      m.uiComponents = []
      groupComponentObject = invalid
    end if

    for i = index to riversCount - 1 step 1

      if m.uiComponents.count() > batchSize
        proceedCreating = true
        exit for
      end if

      component = m.riversJson.ui_components[i]

      if component.component_type = "quick-brick-smart-component"
        m.log.info("super component found, including it")
        m.savedIndex = i
        notificationScreenId = `isSmartComponentLoaded${m.screenId}`
        m.observeNotification(notificationScreenId, m.resultOfComponentRespond)
        smartComponentObject = m.createSmartComponent(component, m.screenId)
        exit for
      else if component.component_type = "group-qb"
        m.log.info("group component found, including it")
        m.savedIndex = i
        notificationScreenId = `isGroupComponentLoaded${m.screenId}_${m.savedIndex}`
        m.observeNotification(notificationScreenId, m.resultOfComponentRespond)
        screenIdIndex = `${m.screenId}_${m.savedIndex}`
        groupComponentObject = m.createGroupComponent(component, screenIdIndex, true)
        exit for
      else
        m.uiComponents.push(component)
        m.savedIndex = i
      end if
    end for

    if m.uiComponents.count() = riversCount and groupComponentObject = invalid or (m.savedIndex = 0 and m.errorComponentIndex.count() + m.uiComponents.count() >= riversCount) or proceedCreating
      m.proceedCreatingContentSearch()
    end if
  end function

  private function createSmartComponent(componentJson, screenId)
    return new SmartComponentVM(componentJson, screenId)
  end function

  private function createGroupComponent(componentJson, screenId, isSearch)
    return new GroupComponentVM(componentJson, screenId, isSearch)
  end function

  function resultOfComponentRespond(componentItems as mc.types.assocarray)
    m.unObserveNotification(componentItems.name)
    data = asArray(componentItems.data)

    if data.count() = 0
      m.log.error("No items found in component")
      m.errorComponentIndex.push(m.savedIndex)
    else
      m.log.error("Found some items")
      for each item in data
        m.uiComponents.push(item)
      end for
    end if

    if m.savedIndex = m.riversJson.ui_components.count() - 1
      m.proceedCreatingContentSearch()
    else
      m.includeAdditionalComponentIfNeeded(m.savedIndex + 1, false)
    end if
  end function

  private function proceedCreatingContentSearch()
    m.log.method("createContent")
    newComponents = []
    newMoveableComponents = []
    componentYOffsets = []
    rowRepeater = invalid

    repeaterCount = 0
    componentIndex = 0
    generalScreenStyle = asAA(m.riversJson.styles)

    for each componentJson in m.uiComponents
      mc.setOrAddNodeField(componentJson.styles, "isPlatformAlignment", true)
      component = m.uiBuilderFactory@.createComponent(componentJson.id, componentJson.component_type, { screenState: m.screenState })
      componentIndex++

      if component <> invalid and (component.subtype() = "ZUIBHorizontalList" or component.subtype() = "ZUIBList")

        m.log.info("this component is repeater compatible - adding it to repeater")

        if mc.getPath(componentJson, "component_type") = "horizontal_list_qb"
          componentJson = zapp.platformAlignmentUtils.transformSamsungHorizontalListToRoku(componentJson, generalScreenStyle)
          forceNewRepeater = true
        end if
        if rowRepeater = invalid

          m.log.info("there was no repeater, creating...")
          repeaterCount++
          rowRepeater = m.createInstance("RowRepeater", invalid, "repeater" + str(repeaterCount).trim())
          rowRepeater.screenState = m.screenState
          isPlatformAlignment = asBoolean(componentJson.styles.isPlatformAlignment)

          rowRepeater.containerClippingOffsets = m.getClippingOffsets(componentJson.styles)
          repeaterRows = []

          groupTopPadding = zapp.viewUtils.getUIBInt(componentJson, "styles.group_top_padding", 0)
          componentTopPadding = zapp.viewUtils.getUIBInt(componentJson, "styles.component_padding_top", 0)
          componentMargins = zapp.viewUtils.makeUIBMargin(componentJson.styles, "component")
          componentPaddings = zapp.viewUtils.makeUIBPadding(componentJson.styles, "component")
          containerOffset = zapp.viewUtils.getUIBInt(componentJson, "styles.multi_container_y_offset", 200) + zapp.viewUtils.getUIBInt(componentJson, "styles.top_margin", 0)
          containerHeightOverride = zapp.viewUtils.getUIBInt(componentJson, "styles.multi_container_force_height", 0) + zapp.viewUtils.getUIBInt(componentJson, "styles.bottom_margin", 0)

          previousComponent = newMoveableComponents[componentIndex - 2]
          if previousComponent <> invalid and asString(previousComponent.riversJson.component_type) = "group-info-qb"
            containerOffset += previousComponent.groupHeight
          end if


          rowBackgroundColor = zapp.viewUtils.transposeUIBColor(componentJson.styles.component_background_color, "#ffffff00")
          zapp.viewUtils.setBackgroundColor(rowRepeater, "rowBackgroundVisible", "rowBackgroundColor", rowBackgroundColor)

          component.isDisplayedInSearch = true
          component.containerYOffset = containerOffset
          rowRepeater.groupBottomMargin = zapp.viewUtils.getUIBInt(componentJson, "styles.group_bottom_margin", 0)
          rowRepeater.groupTopPadding = groupTopPadding
          rowRepeater.componentPaddings = componentPaddings
          rowRepeater.componentTopPadding = componentTopPadding
          rowRepeater.componentMargins = componentMargins
          rowRepeater.containerYOffset = component.containerYOffset
          rowRepeater.containerHeightOverride = containerHeightOverride
          rowRepeater.rowList.translation = [0, groupTopPadding + componentTopPadding + asInteger(componentMargins.marginTop)]
          componentYOffsets.push(component.containerYOffset)
        end if

        component.riversJson = componentJson
        'bs:disable-next-line
        repeaterRows.push(component)

      else if component <> invalid
        m.log.info("creating non repeated component")
        if mc.getPath(componentJson, "component_type") = "grid-qb"
          componentJson = zapp.platformAlignmentUtils.transformSamsungGridToRoku(componentJson, generalScreenStyle)
        else if mc.getPath(componentJson, "component_type") = "hero-qb"
          componentJson = zapp.platformAlignmentUtils.transformSamsungHeroToRoku(componentJson, generalScreenStyle)
        else if mc.getPath(componentJson, "component_type") = "gallery-qb"
          componentJson = zapp.platformAlignmentUtils.transformSamsungGalleryToRoku(componentJson, generalScreenStyle)
        end if
        'bs:disable-next-line
        zapp.GeneralScreenUtils.finishRepeater(rowRepeater, newComponents, newMoveableComponents, repeaterRows)
        rowRepeater = invalid

        m.log.info("component type is ", component.subtype())

        component.screenState = m.screenState
        component@.initializeWithRiversJson(componentJson)
        component.visible = true

        backgroundColor = zapp.viewUtils.transposeUIBColor(componentJson.styles.group_color, "#ffffff00")
        rowBackgroundColor = zapp.viewUtils.transposeUIBColor(componentJson.styles.component_background_color, "#ffffff00")
        childBackgroundColor = zapp.viewUtils.transposeUIBColor(componentJson.styles.child_background_color, "#ffffff00")
        zapp.viewUtils.setBackgroundColor(component, "backgroundVisible", "backgroundColor", backgroundColor)
        zapp.viewUtils.setBackgroundColor(component, "rowBackgroundVisible", "rowBackgroundColor", rowBackgroundColor)
        zapp.viewUtils.setBackgroundColor(component, "childBackgroundVisible", "childBackgroundColor", childBackgroundColor)

        component.groupBottomMargin = zapp.viewUtils.getUIBInt(componentJson, "styles.group_bottom_margin", 0)
        component.componentMargins = zapp.viewUtils.makeUIBMargin(componentJson.styles, "component")

        newComponents.push(component)
        if component.isBackgroundView <> true
          newMoveableComponents.push(component)
        end if

        if asString(component.riversJson.component_type) = "group-info-qb"
          component.isFocusable = false
          mc.setOrAddNodeField(component, "isGroupInfo", true)
        else if asString(component.riversJson.component_type) = "empty_group_component"
          component.isFocusable = false
        end if

        if not (component.isFullScreen = true or component.isBackgroundView = true)
          groupTopPadding = zapp.viewUtils.getUIBInt(componentJson, "styles.group_top_padding", 0)
          componentPaddings = zapp.viewUtils.makeUIBPadding(componentJson.styles, "component")
          containerOffset = zapp.viewUtils.getUIBInt(componentJson, "styles.multi_container_y_offset", 200) + zapp.viewUtils.getUIBInt(componentJson, "styles.top_margin", 0)
          containerHeightOverride = zapp.viewUtils.getUIBInt(componentJson, "styles.multi_container_force_height", 0) + zapp.viewUtils.getUIBInt(componentJson, "styles.bottom_margin", 0)

          previousComponent = newMoveableComponents[componentIndex - 2]
          if previousComponent <> invalid and asString(previousComponent.riversJson.component_type) = "group-info-qb"
            containerOffset += previousComponent.groupHeight
          end if

          component.isDisplayedInSearch = true
          component.groupBottomMargin = zapp.viewUtils.getUIBInt(componentJson, "styles.group_bottom_margin", 0)
          component.groupXYDimension = asArray(componentJson.styles.groupXYDimension, [0, 0, 0])
          component.groupTopPadding = groupTopPadding
          component.componentPaddings = componentPaddings
          component.containerYOffset = zapp.viewUtils.getUIBInt(componentJson, "styles.multi_container_clipping_offset_h")
          component.containerHeightOverride = containerHeightOverride
          componentYOffsets.push(containerOffset)
        end if
      else
        m.log.error("could not instantiate component for this json")
      end if
    end for

    'bs:disable-next-line
    zapp.GeneralScreenUtils.finishRepeater(rowRepeater, newComponents, newMoveableComponents, repeaterRows)

    m.components = newComponents
    m.moveableComponents = newMoveableComponents
    m.componentYOffsets = componentYOffsets
    m.isDisplayedInDynamicContainer = true
    for each comp in m.components
      m.observeNodeField(comp, "state", zapp.GeneralScreenUtils.onChildComponentStateChange)
    end for

    m.log.info(">>>>", m.components.count())
    if m.components.count() > 0
      m.log.info("view is init'd")
      m.state = "initialized"
      zapp.GeneralScreenUtils.selectFirstComponent()
      m.load()
    else
      m.state = "error"
    end if

  end function

  private function selectNextComponent(isCheck = false)
    return zapp.GeneralScreenUtils.selectNextComponent(isCheck)
  end function

  private function selectPreviousComponent(isCheck = false)
    return zapp.GeneralScreenUtils.selectPreviousComponent(isCheck)
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Set Styles
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function processStyles(styles)
    textStyleFormat = {
      search_label_placeholder_color: mc.getPath(styles, "search_label_placeholder_font_color")
      search_label_color: mc.getPath(styles, "search_label_font_color")
      search_label_highlighted_color: mc.getPath(styles, "search_label_focused_font_color")
      search_label_font_name: mc.getPath(styles, "search_label_samsung_font_family")
      search_label_font_size: zapp.viewUtils.getUIBInt(styles, "search_label_samsung_font_size")
      search_label_line_height: zapp.viewUtils.getUIBInt(styles, "search_label_samsung_line_height")
      search_label_letter_spacing: zapp.viewUtils.getUIBInt(styles, "search_label_samsung_letter_spacing")
      search_label_alignment: mc.getPath(styles, "search_label_text_alignment", "center")
      search_label_transform: mc.getPath(styles, "search_label_text_transform", "uppercase")
      search_label_margin_top: zapp.viewUtils.getUIBInt(styles, "search_label_margin_top")
      search_label_margin_bottom: zapp.viewUtils.getUIBInt(styles, "search_label_margin_bottom")
      search_label_margin_left: zapp.viewUtils.getUIBInt(styles, "search_label_margin_left")
      search_label_margin_right: zapp.viewUtils.getUIBInt(styles, "search_label_margin_right")
    }
    textStyle = zapp.viewUtils.makeUIBButtonStyle(textStyleFormat, "search_label", invalid, invalid, false, "vert", true)

    itemStyle = {
      text: textStyle
      textAlign: textStyleFormat.search_label_alignment
      menuList: {
        marginStyle: zapp.viewUtils.makeUIBMargin(styles, "menu_list")
        paddingStyle: zapp.viewUtils.makeUIBPadding(styles, "menu_list")
        openColorBg: zapp.viewUtils.transposeUIBColor(styles.menu_list_open_background_color)
        openColorBr: zapp.viewUtils.transposeUIBColor(styles.menu_list_open_border_color)
        closedColorBg: zapp.viewUtils.transposeUIBColor(styles.menu_list_closed_background_color)
        closedColorBr: zapp.viewUtils.transposeUIBColor(styles.menu_list_closed_border_color)
        borderWidth: zapp.viewUtils.getUIBInt(styles, "menu_list_border_width")
        cornerRadius: zapp.viewUtils.getUIBInt(styles, "menu_list_corner_radius")
        alignment: mc.getPath(styles, "menu_list_alignment", "center")
      }
      itemMenuBackground: {
        placeholderBg: zapp.viewUtils.transposeUIBColor(styles.search_bar_background_placeholder_color)
        normalBg: zapp.viewUtils.transposeUIBColor(styles.search_bar_background_color)
        highlightedBg: zapp.viewUtils.transposeUIBColor(styles.search_bar_background_focus_color)
        placeholderBr: zapp.viewUtils.transposeUIBColor(styles.border_placeholder_color)
        normalBr: zapp.viewUtils.transposeUIBColor(styles.border_color)
        highlightedBr: zapp.viewUtils.transposeUIBColor(styles.border_focus_color)
        borderWidth: zapp.viewUtils.getUIBInt(styles, "border_thickness")
        cornerRadiusBr: zapp.viewUtils.getUIBInt(styles, "search_bar_background_border_radius")
        paddingStyle: zapp.viewUtils.makeUIBPadding(styles, "search_bar")
      }

      icon: {
        isEnabled: asBoolean(styles.search_icon_asset_enabled)
        assetWidth: zapp.viewUtils.getUIBInt(styles, "search_icon_asset_width")
        assetHeight: zapp.viewUtils.getUIBInt(styles, "search_icon_asset_height")
        marginStyle: zapp.viewUtils.makeUIBMargin(styles, "search_icon_asset")
      }
      underLineIndicator: m.getIndicatorStyle(styles, "indicator_bottom")
    }

    m.minCharacters = zapp.viewUtils.getUIBInt(styles, "search_min_chars", 3)

    menuItem = createObject("roSGNode", "MenuItemContent")
    menuItem.isSelectable = false
    menuItem.isPlaceholder = true
    menuItem.title = asString(m.localizations.placeholder_message, "Search")
    m.searchTextInput = asString(m.localizations.placeholder_message, "Search")

    m.setMenuItemAssets(menuItem, styles)
    m.keyboardItem = menuItem

    keyboard = m.getMField("keyboard")
    if keyboard <> invalid
      positioning = [zapp.viewUtils.getUIBInt(styles, "search_bar_x_position"), zapp.viewUtils.getUIBInt(styles, "search_bar_y_position")]
      keyboard.translation = positioning
      keyboard.width = zapp.viewUtils.getUIBInt(styles, "search_bar_width", 1672)
      keyboard.text = menuItem.title
      keyboard.style = itemStyle
    end if
  end function

  private function getIndicatorStyle(styles, prefix)
    return {
      isEnabled: true
      placeholderColor: zapp.viewUtils.transposeUIBColor(styles[`${prefix}_placeholder_color`])
      color: zapp.viewUtils.transposeUIBColor(styles[`${prefix}_color`])
      focusedColor: zapp.viewUtils.transposeUIBColor(styles[`${prefix}_focus_color`])
      selectedColor: "#00000000"
      focusedSelectedColor: "#00000000"
      cornerRadius: zapp.viewUtils.getUIBInt(styles, `${prefix}_corner_radius`)
      marginStyle: zapp.viewUtils.makeUIBMargin(styles, prefix)
      thickness: zapp.viewUtils.getUIBInt(styles, `${prefix}_thickness`)
    }
  end function

  private function setMenuItemAssets(menuItem, assets)
    isEnabled = asBoolean(assets.search_icon_asset_enabled)
    if isEnabled
      menuItem.placeholderUri = zapp.viewUtils.getPosterUri(assets.search_icon_asset_placeholder)
      menuItem.uri = zapp.viewUtils.getPosterUri(assets.search_icon_asset)
      menuItem.highlightedUri = zapp.viewUtils.getPosterUri(assets.search_icon_asset_focus, "", "focused")
      menuItem.footprintUri = zapp.viewUtils.getPosterUri(assets.icon_image_selected, "", "selected")
      menuItem.highlightedFootprintUri = zapp.viewUtils.getPosterUri(assets.icon_image_focused_selected)
    end if
  end function

  function processTabStyles(styles as mc.types.assocarray)
    textHorizAlign = asString(styles.tab_bar_item_alignment, "center")
    m.isButtonDynamic = asString(styles.tab_bar_item_size) <> "fixed"
    m.isDynamicGroupSize = asString(styles.tab_bar_display_mode) <> "fixed"

    buttonType = "custom"
    if m.isButtonDynamic
      buttonType = "customLeft"
    else if textHorizAlign = "left"
      m.labelXOffset = -24
      buttonType = "customLeft"
    else if textHorizAlign = "right"
      m.labelXOffset = -24
      buttonType = "customRight"
    end if

    m.textTransform = asString(styles.text_transform, "uppercase")
    m.buttonSpacing = zapp.viewUtils.getUIBInt(styles, "tab_bar_gutter")
    m.tabComponentPaddings = zapp.viewUtils.makeUIBPadding(m.riversJson.styles, "component")

    m.setMenuStyle(styles, buttonType)
    m.setMenuGroupStyle(styles, buttonType)
  end function

  private function setMenuStyle(styles as mc.types.assocarray, buttonType as string)
    layoutDirection = asString(styles.tab_bar_direction, "horiz")
    menuStyle = zapp.viewUtils.makeUIBButtonStyle(styles, "tab_bar_item", buttonType, "", true, layoutDirection, true)
    menuStyle.layoutDirection = layoutDirection
    menuStyle.menuTextPadding = zapp.viewUtils.makeUIBPadding(styles, "tab_bar_item")
    menuStyle.isBorderGenerated = true
    m.menuStyle = menuStyle
  end function

  private function setMenuGroupStyle(styles as mc.types.assocarray, buttonType as string)
    menuGroupStyle = zapp.viewUtils.makeUIBButtonStyle(styles, "tab_bar", buttonType, "", true, m.layoutDirection, true)
    borderSize = zapp.viewUtils.getUIBInt(styles, "tab_bar_border_w")
    cornerRadius = zapp.viewUtils.getUIBInt(styles, "tab_bar_border_radius")
    backgroundcolor = asString(menuGroupStyle.normal.backgroundcolor, "#00000000")
    backgroundBorderColor = asString(menuGroupStyle.normal.backgroundbordercolor, "#00000000")

    m.setBackgroundVisibility(backgroundcolor, m.backgroundPoster)
    m.setBackgroundVisibility(backgroundBorderColor, m.backgroundBorderPoster)

    if m.backgroundPoster <> invalid
      m.adjustPoster(m.backgroundPoster, menuGroupStyle, borderSize, cornerRadius, "", false)
      m.adjustPoster(m.backgroundBorderPoster, menuGroupStyle, borderSize, cornerRadius, "Border", true)
    end if
  end function

  function setBackgroundVisibility(color, background)
    if color.endsWith("00")
      background.uri = "transparent"
    end if
  end function

  private function adjustPoster(poster as mc.types.node, style as mc.types.assocarray, borderSize as integer, cornerRadius as integer, prefix as string, isBorder as boolean)
    if isBorder
      clampWidth = m.isDynamicGroupSize ? 1920 : style.width
      poster.width = mc.clamp(style.width + borderSize, 0, clampWidth)
      poster.height = style.height + borderSize
      poster.translation = style.translation
      if poster.uri <> "transparent"
        zapp.viewUtils.drawImageBorder(poster, zapp.viewUtils.setPosterStyleForDraw(poster.width, 0, cornerRadius, borderSize))
      end if
    else
      poster.width = style.width - (borderSize * 2)
      poster.height = style.height - borderSize
      poster.translation = [borderSize, borderSize]
      posterCornerRadius = mc.clamp(cornerRadius - borderSize, 0, cornerRadius)
      if poster.uri <> "transparent"
        zapp.viewUtils.drawImage(poster, zapp.viewUtils.setPosterStyleForDraw(poster.width, 0, posterCornerRadius, borderSize))
      end if
    end if

    poster.blendColor = style.normal[`background${prefix}color`]
  end function

  private function setButtonAlignment()
    topMargin = zapp.viewUtils.getUIBInt(m.riversJson.styles, "component_margin_top")
    tabBarAlignment = asString(m.riversJson.styles.tab_bar_alignment, "left")
    componentPaddings = m.tabComponentPaddings
    componentMargin = asAA(m.menuStyle.marginStyle)
    menu = m.buttonMenu
    componentWidth = 1920
    containerWidth = m.backgroundBorderPoster.width
    innerContainerWidth = m.backgroundPoster.width
    menuWidth = menu.boundingRect().width
    yOffset = menu.translation[1] + componentPaddings.paddingTop
    menuYOffset = yOffset + asInteger(componentMargin.marginTop)
    if tabBarAlignment = "right"
      m.buttonContainerTranslation = [componentWidth - containerWidth, yOffset]
      m.buttonTranslation = [innerContainerWidth - menuWidth - componentPaddings.paddingRight + asInteger(componentMargin.marginRight), menuYOffset]
    else if tabBarAlignment = "center"
      m.buttonContainerTranslation = [(componentWidth * 0.5) - (containerWidth * 0.5), yOffset]
      m.buttonTranslation = [(innerContainerWidth * 0.5) - (menuWidth * 0.5) + componentPaddings.paddingLeft - componentPaddings.paddingRight + asInteger(componentMargin.marginLeft), menuYOffset]
    else
      m.buttonContainerTranslation = [0, yOffset]
      m.buttonTranslation = [componentPaddings.paddingLeft + asInteger(componentMargin.marginLeft), menuYOffset]
    end if

    m.searchFlowLayout.itemSpacings = [topMargin, 0]
  end function

  private function setDynamicSizeIfNeeded()
    componentPaddings = m.tabComponentPaddings
    menu = m.buttonMenu
    borderSize = zapp.viewUtils.getUIBInt(m.riversJson.styles, "tab_bar_border_w")
    height = menu.boundingRect().height + componentPaddings.paddingTop + componentPaddings.paddingBottom
    m.backgroundPoster.height = height
    m.backgroundBorderPoster.height = height + (2 * borderSize)

    if m.isDynamicGroupSize
      width = menu.boundingRect().width + componentPaddings.paddingLeft + componentPaddings.paddingRight
      m.backgroundPoster.width = width
      m.backgroundBorderPoster.width = width + (2 * borderSize)
    end if
  end function

  private function setScreenLocalizations(localization)
    language = m.getInstance("languageCode") ?? "en"
    m.localizations = asAA(localization[language])
  end function

  private function createButtonsWithFeed(entry as mc.types.node)
    if asBoolean(entry.isOk)
      data = entry.data
      menuButtons = []
      i = 0
      for each item in data.getChildren(-1, 0)
        id = "item" + str(i).trim()
        text = item.title
        text = zapp.viewUtils.textToTextTransformFormat(text, m.riversJson.styles.text_transform)

        menuButtons.push({
          id: id
          title: text
          entry: item
        })
        i++
      end for
      m.menuButtons = menuButtons
      m.isFilterFocusable = m.menuButtons.count() > 0
      m.applySearchFilterDefaultState()
      m.setDynamicSizeIfNeeded()
      m.setButtonAlignment()
      m.tabIsLoaded = true
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Screen Management
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function showFirstScreen()
    screen = m.getScreen(m.fallbackScreen)
    if screen <> invalid
      m.setScreenParent(screen)
      screen.isFirstScreen = true
      m.toggleSubScreen(screen)
    end if
  end function

  private function setScreenParent(screen as mc.types.node)
    parent = screen.getParent()
    m.nameOfParentScreen = asString(parent.name)
  end function

  function toggleSubScreen(screen)
    m.log.method("toggleSubScreen")

    m.unobserveNodeField(m.currentScreen, "state", m.onSubScreenStateChange)

    m.currentScreen = invalid

    if screen <> invalid
      m.currentScreen = screen
      m.onSubScreenStateChange(m.currentScreen.state)
      m.observeNodeField(m.currentScreen, "state", m.onSubScreenStateChange)
    end if

  end function

  private function onSubScreenStateChange(state as string)
    if state = "initialized"
      m.isScreenContainerVisible = true
      m.isGridVisible = false
      m.currentScreen.visible = true
      m.isFirstLoadComplete = true
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ overridden
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public override function load()
    m.state = "ready"
    m.isLoading = false
    zapp.GeneralScreenUtils.load()
  end function

  public function checkCredsValid()
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ callbacks
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function onSearchKeyboardDialogDismissal(text)
    m.log.method("onSearchKeyboardDialogDismissal", text)

    if text.trim() = ""
      m.searchText = ""
      m.searchTextInput = asString(m.localizations.placeholder_message, "Search")
      m.keyboardItem.isPlaceholder = true
    else
      m.searchTextInput = text
      m.searchText = text
      m.keyboardItem.isPlaceholder = false
    end if
    m.setTextFromKeyboard("searchText", text)
    m.onSearchTextChange(text)
  end function

  public function onSearchButtonSelected(value)
    m.log.info("onSearchButtonSelected", value)
    palette = zapp.viewUtils.getUIBKeyboardDialogPalette(m.riversJson.styles, "keyboard")
    m.showKeyboardDialog("Enter your search", m.searchText, "onSearchKeyboardDialogDismissal", false, "none", palette)
  end function

  public function onSearchTextChange(text)
    m.log.info("text is now", text, "waiting before searching")

    m.searchText = text
    m.cancelWaitTimer(m.searchDelayTask)
    m.cancelTask(m.loadDataTask)

    if len(m.searchText.trim()) >= m.minCharacters
      m.searchDelayTask = m.waitAFrame(m.onSearchDelayComplete, 0.5)
      m.isShowingContent = true
    else
      m.log.verbose("too few chars. ignoring")
      m.setGridVisible(false)
      m.setScreenContainerVisible(true)
      m.isLoading = false
      m.applySearchFilterDefaultState()
      m.checkIfSearchWasCanceled()
    end if
  end function

  public function onSearchDelayComplete()
    m.log.method("onSearchDelayComplet")
    m.searchDelayTask = invalid
    m.log.verbose("search debounce complete, executing search with", m.searchText)
    m.performSearch(m.searchText)
  end function

  public function onSelectedIndexChange(index as integer)
    m.log.info("selected index", index)
    m.selectedFilterIndex = index
    m.screenState.originEntry = asAA(m.menuButtons[m.selectedFilterIndex].entry)

    if len(m.searchText.trim()) >= m.minCharacters
      m.toggleLoadingDataTask(true, { "search": m.searchText.trim().encodeUriComponent() }, m.loadDepth)
    end if
  end function

  public function onFocusIndexChange(index)
    m.log.info("focused index", index, "isShowingScreenOnFocus", m.isShowingScreenOnFocus)
    m.savedIndex = index
    m.waitAFrame(m.onFocusIndexChangeComplete, 0.1)
  end function

  function onFocusIndexChangeComplete()
    m.focusedFilterIndex = m.savedIndex
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ search api invocation
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function performSearch(text)
    m.log.method("performSearch")

    m.isLoading = true
    m.setGridVisible(true)

    searchText = text.trim().encodeUriComponent()

    m.toggleLoadingDataTask(true, { "search": searchText }, m.loadDepth)
  end function

  public override function toggleLoadingDataTask(isActive, componentValues = invalid, depth = 1)
    m.log.info("toggleLoadingDataTask", isActive)
    m.loadDataTaskTimer = new zapp.DebugTimer("VM.Feed" + m.name)

    if m.loadDataTask <> invalid
      m.cancelTask(m.loadDataTask)
      m.loadDataTask = invalid
    end if

    if isActive
      m.riversJson.data = m.searchData

      for each item in m.components
        mc.setOrAddNodeField(item.riversJson, "componentValues", componentValues)
        json = item.riversJson
        mc.setPath(json, "componentValues", componentValues)
        item.riversJson = json
        item.isDataRefreshRequired = true
        item.visible = false
      end for
      if mc.getPath(m.riversJson, "data.source", "").trim() <> ""
        m.load()
        m.loadDataTask = m.executeloadDataTask("componentFeed", m.onFeedResult, componentValues, depth)
      else
        m.log.error("tried to load entry without a link")
        m.onFeedResult({ isOK: false, data: invalid })
      end if
    end if


    '// all visible false if empty then visible true
    m.isLoading = m.loadDataTask <> invalid
  end function

  public override function onFeedResult(result)
    m.log.method("onFeedResult")
    m.toggleLoadingDataTask(false)
    m.isLoading = false
    results = result.data
    if results <> invalid
      m.sendSearchExecutedEvent(results.getChildCount())
    else
      m.sendSearchExecutedEvent(0)
    end if

    if result.isOk and results <> invalid
      m.setContentStyle(results)
      numItems = result.data.getChildCount()
      m.feed = result.data
      m.isFilterVisible = numItems > 0 and m.isSearchFilterEnabled
      if numItems <= 0
        m.searchHaveResults = false
        m.sendSearchNoResultEvent()
      else
        m.searchHaveResults = true
      end if
    else
      results = createObject("roSGNode", "ZPEntry")
      m.searchHaveResults = false
      m.sendSearchNoResultEvent()
    end if
    components = m.components
    for each item in components
      if asString(item.riversJson.component_type) = "empty_group_component"
        item.visible = not m.searchHaveResults
      else
        item.visible = m.searchHaveResults
      end if
    end for

    m.components = components
    m.needsRecalculating = true
    m.results = results
    m.setGridVisible(true)
    m.setScreenContainerVisible(false)
  end function

  private function applySearchFilterDefaultState()
    m.isFilterVisible = false
    m.jumpSelectToIndex = 0
    m.onSelectedIndexChange(0)
  end function

  private function setScreenContainerVisible(visible)
    if not m.isGridVisible
      m.isScreenContainerVisible = true and m.currentscreen <> invalid and visible
    else
      m.isScreenContainerVisible = false
    end if

    if not m.isGridVisible and m.focusId = "grid"
      m.setFocusId("keyboard")
      m.isScreenContainerVisible = true and m.currentscreen <> invalid
    end if
  end function

  private function setGridVisible(isGridVisible)
    m.isGridVisible = isGridVisible

    if not m.isGridVisible
      m.results = createObject("roSGNode", "ZPEntry")
    end if

    if not m.isGridVisible and m.focusId = "grid"
      m.setFocusId("keyboard")
    end if
  end function

  private function setContentStyle(content)
    m.log.method("setContentStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    else
      m.log.error("Cannot set content: there is no cell style set")
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Private Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function findNextFocusable(newIndex)
    for i = newIndex + 1 to m.moveableComponents.count() - 1
      if m.moveableComponents[i].isFocusable and m.moveableComponents[i].visible
        newIndex = i
        m.log.info("skipping to next focusable component at index", newIndex)
        exit for
      end if
    end for
    return newIndex
  end function

  private function findPreviousFocusable(newIndex)
    for i = newIndex - 1 to 0 step -1
      if m.moveableComponents[i].isFocusable and m.moveableComponents[i].visible
        newIndex = i
        m.log.info("skipping to previous focusable component at index", newIndex)
        exit for
      end if
    end for
    return newIndex
  end function

  private function checkIfSearchWasCanceled()
    if m.searchHaveResults and not m.itemWasSelected
      m.sendSearchCanceledEvent()
    end if
    m.searchHaveResults = false
    m.itemWasSelected = false
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Analytic Events
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function sendSearchExecutedEvent(numItems)
    analyticsProperties = m.setDefaultProperties()
    analyticsProperties.append({
      "result_count": numItems
    })
    m.sendAnalyticsEvent(zapp.analytics.EventType.searchExecuted, analyticsProperties, m.getScreenProperties())
  end function

  private function sendSearchNoResultEvent()
    analyticsProperties = m.setDefaultProperties()
    m.sendAnalyticsEvent(zapp.analytics.EventType.searchNoResultFound, analyticsProperties, m.getScreenProperties())
  end function

  private function sendSearchTapCellEvent(selection, index)
    analyticsProperties = m.setDefaultProperties()
    cellProperties = m.getCellProperties(selection, index)
    analyticsProperties.append({
      "tap_cell": cellProperties
    })
    m.sendAnalyticsEvent(zapp.analytics.EventType.searchTapCell, analyticsProperties, invalid, invalid, cellProperties)
  end function

  private function sendSearchCanceledEvent()
    analyticsProperties = m.setDefaultProperties()
    m.sendAnalyticsEvent(zapp.analytics.EventType.searchCanceled, analyticsProperties, m.getScreenProperties())
  end function

  private function setDefaultProperties()
    return {
      "query_length": len(m.searchText.trim())
      "query_text": m.searchText
      "event_timestamp": createObject("roDateTime").toISOString()
    }
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ keyboard
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  override function onKeyPressUp() as boolean
    if m.isFilterFocusable and m.focusId = "grid" and not m.selectPreviousComponent(true)
      m.setFocusId("menu")
      return true
    else if m.focusId = "menu" or (m.focusId = "grid" and not m.selectPreviousComponent(true)) or m.focusId = "screenContainer"
      m.setFocusId("keyboard")
      return true
    else if m.focusId = "grid"
      if m.selectPreviousComponent(true)
        m.componentIndex = m.findPreviousFocusable(m.componentIndex)
      end if
    end if
    return false
  end function

  function onKeyPressDown() as boolean
    if m.focusId = "keyboard"
      if m.isFilterFocusable and m.isFilterVisible
        m.setFocusId("menu")
        return true
      else if m.isGridVisible and m.results.getChildCount() > 0
        m.setFocusId("grid")
        return true
      else if m.isScreenContainerVisible
        m.setFocusId("screenContainer")
        return true
      end if
    else if m.focusId = "menu"
      if m.isGridVisible
        m.setFocusId("grid")
        return true
      else if m.isScreenContainerVisible
        m.setFocusId("screenContainer")
        return true
      end if
    else if m.focusId = "grid"
      if m.selectNextComponent(true)
        m.componentIndex = m.findNextFocusable(m.componentIndex)
      end if
    end if
    return false
  end function

  function isCapturingAnyKeyPress(key as string, press as boolean) as boolean
    if key = "up" and m.focusId = "keyboard"
      return false
    end if
    return true
  end function

  override function reset()
    m.results = createObject("roSGNode", "ZPEntry")
    m.setGridVisible(false)
    m.setScreenContainerVisible(true)
    m.searchText = ""
    m.applySearchFilterDefaultState()

    if m.isSearchFilterEnabled and not m.tabIsLoaded
      m.riversJson.data = m.filterData
      m.executeloadDataTask("componentFeed", m.createButtonsWithFeed, invalid, 0)
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ lifecycle
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  protected override function onHide()
    super.onHide()

    m.cancelWaitTimer(m.searchDelayTask)
    m.cancelTask(m.loadDataTask)
    m.checkIfSearchWasCanceled()
    m.loadDataTask = invalid
    m.searchDelayTask = invalid
  end function

  protected override function onShow() as void
    m.log.method("onShow")
    m.trackScreen()
    if not m.isShowingContent and len(m.searchText.trim()) < m.minCharacters
      m.reset()
    end if

    if m.isFirstLoadComplete
      m.log.info("search fallbackScreen already loaded")
    else
      m.showFirstScreen()
    end if

    m.isShowingContent = false
  end function

end class
