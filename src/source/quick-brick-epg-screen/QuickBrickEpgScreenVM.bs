import "pkg:/source/authorization/BaseAuthPlugin.bs"
import "pkg:/source/authorization/JWTUtil.bs"
import "pkg:/source/lib/BaseClass.bs"
import "pkg:/source/lib/APIUtils.bs"
import "pkg:/source/UIBuilder/view/Component.bs"
import "pkg:/source/zapp-controls/BaseCollectionRowVM.bs"
import "pkg:/source/lib/ViewUtils.bs"
import "pkg:/source/zapp-pipes/EntryLoader.bs"

enum ButtonAction
  play = "play"
  info = "info"
  favorite = "favorite"
end enum

class QuickBrickEpgScreenVM extends zapp.uib.ComponentVM

  'styling
  public menuButtons = []
  public titleTextStyle = {}
  public menuStyle = {}
  public menuPosition = [960, 584]
  public buttonSize = [700, 100]
  public buttonSpacing = 5
  public jumpToIndex = -1
  public dayButtonStyle = invalid
  public filterButtonStyle = invalid

  'public content = m.createSGNode("CollectionRow")
  public gridStyle = {}
  public results = invalid
  public channelIndex = -1
  public programIndex = -1
  public channelFocused = 0
  public content = invalid
  public listContent = invalid
  public listStyle = {}
  public itemList = false
  public contentStartTime = {}

  private jwtUtil = new zapp.JWTUtil()
  private timeout = invalid
  private loadChannelTask = invalid
  private loadProgramTask = invalid
  private focusRectangle = invalid
  private channelItem = invalid
  private timeGridContent = invalid
  private contentLoader = new zapp.pipes.EntryLoader()

  private focusIds = ["button1", "button2"]
  private riversJsonData = invalid
  private contentDepth = 1
  private taskCount = invalid
  private programsData = []
  private channelCount = invalid
  private focusIndex = 0
  private localizations = invalid
  private isUsingButtons = true
  private cellStyle
  private controlsGroup as mc.types.node
  private button1 as mc.types.node
  private button2 as mc.types.node
  private buttonActionMap = {
    open_day_tab_action: ButtonAction.play
    open_channel_filter_tab: ButtonAction.favorite
  }

  @inject("constants")
  private constants

  @injectClass("zapp.PluginManager")
  private plugins

  ' /**
  '  * @module QuickBrickEpgScreenVM
  '  * @description
  ' **/
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Overridden Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function new(riversJson)
    super(riversJson, "QuickBrickEpgScreenVM")
    m.setEpgStyle(riversJson.styles)
    'm.makeEPGData(riversJson.data)
    'm.removingGridGap()
    'm.updateButtons(riversJson.styles)
    m.style = m.getChildCellStyle(riversJson)
    m.updateFocusControls()
    m.riversJsonData = riversJson
    m.focusId = "button1"
    m.contentDepth = zapp.viewUtils.getUIBInt(riversJson.styles, "data_depth", 1)
  end function

  public override function load()
    m.makeEPGData(m.riversJsonData)
    m.epgHardcodedStyle(m.riversJsonData.styles)
    'm.updateButtons(m.riversJsonData.styles)
    return true
  end function

  public override function resetStyles(riversJson)
    m.log.method("resetStyles")
    super.resetStyles(riversJson)
    m.setEpgStyle(riversJson.styles)
    m.setContentStyle(m.feed)

    m.feed = m.feed
    ' m.waitAFrame(m.onReloadStyle, 5)
  end function

  public function onDayButtonSelected()
    m.log.info("onDayButtonSelected")
    m.getLocalization()
    items = []
    for each item in m.localizations
      listItem = {
        "title": item
      }
      items.push(listItem)
    end for
    content = m.createContentFromItems(items)
    m.itemList = true
    m.listContent = content
    m.setFocusId("list")
  end function

  public function onFilterButtonSelected()
  end function


  private function applyDataMap(feed as mc.types.node, style as mc.types.assocarray) as void

    if style <> invalid

      if feed <> invalid
        dataSource = feed.getChild(0)
      else
        dataSource = invalid
      end if

      'm.applyDataMapToControls(style.dataMap, dataSource)
    end if

    if m.isFocused
      m.onGainedFocus(true)
    else
      m.focusRectangle.visible = false
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Content creating
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function epgHardcodedStyle(style)
    aaa = m.getMField("top")
    TimeGrid = aaa.getChild(3)
    TimeGrid.programBackgroundBitmapUri = "pkg:/images/TimeGridBackground.9.png"
    TimeGrid.timeBarBitmapUri = ":"
    TimeGrid.channelInfoBackgroundBitmapUri = "pkg:/images/TimeGridBackground.9.png"
    TimeGrid.nowBarBlendColor = "#FF5247"
    TimeGrid.programNowNextTimeFocusedColor = "#FF5247"
    TimeGrid.programTitleColor = "#FFFFFF"
    TimeGrid.programTitleFocusedColor = "#FFFFFF"
    TimeGrid.timeLabelColor = "#FFFFFF"
    TimeGrid.pastTimeScreenBlendColor = "#3D80FF"
    TimeGrid.focusBitmapUri = "pkg:/images/SearchFocusBackground2.9.png"
    TimeGrid.duration = 12600
    TimeGrid.timebarHeight = 120
    TimeGrid.sectionDividerTopOffset = 30
    TimeGrid.numRows = 6
    TimeGrid.channelInfoWidth = 245
    TimeGrid.scrollSpeed = 100
    TimeGrid.overlayBitmapUri = ""
    TimeGrid.nowBarWidth = 60

    TimeGrid.vertFocusAnimationStyle = "floatingFocus"
  end function

  private function createContentFromItems(items)
    if not mc.isArray(items)
      return invalid
    end if

    entryWraper = createObject("roSGNode", "ZPEntry")

    for i = 0 to items.count() - 1
      entry = m.createSGNode("ZPEntry", entryWraper, items[i], {
        title: items[i].title
        json: {
          title: items[i].title
          selected: true
        }
      })
      mc.setOrAddNodeField(entry, "isSelected", true)
    end for
    m.setRowStyle(entryWraper)
    return entryWraper
  end function

  private function setEpgContent(data)
    if asString(data.channels_source.source) <> ""
      m.state = "loading"
      m.loadChannelTask = m.executeloadTaskWithUrl("1", m.onLoadMoreResponse, data.channels_source.source, 0)
    end if
  end function

  private function loadMore()
    m.log.method("loadMore")
    m.state = "loading"
  end function

  private function onLoadMoreResponse(result)
    m.log.method("onLoadMoreResponse")

    m.state = "ready"

    m.timeGridContent = CreateObject("roSGNode", "ContentNode")
    m.taskCount = 0
    m.channelCount = -1
    channelsData = result.data
    programUrl = m.riversJsonData.data.programs_source.source

    for each channelData in channelsData.getChildren(-1, 0)
      m.channelItem = m.timeGridContent.createChild("ContentNode")
      m.channelItem.title = channelData.title
      m.channelItem.HDSMALLICONURL = channelData.json.images.image_base
      actuallUrl = m.substituteIdInUrl(programUrl, channelData.id)
      m.taskCount++
      m.loadProgramTask = m.executeloadTaskWithUrl("1", m.onLoadProgramsResponse, actuallUrl, 0)
    end for
  end function

  private function onLoadProgramsResponse(result)
    m.log.method("onLoadProgramsResponse")
    m.programsData = []
    if result.isOk
      m.channelCount++
      programsData = result.data
      for each programData in programsData.getChildren(-1, 0)
        programItem = m.channelItem.createChild("ContentNode")
        programItem.PLAYSTART = m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programItem.PLAYDURATION = m.parseDateStringToSeconds(programData.json.extensions.end_time) - m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programItem.TITLE = programData.title
        programItem.id = programData.id
        programItem.shortDescriptionLine1 = programData.json.summary
        'programItem.HDSMALLICONURL = programData.json.images.image_base
        m.programsData.push(programItem)
      end for
    end if
    m.programsData.SortBy("PLAYSTART")
    m.timeGridContent.getChild(m.channelCount).appendChildren(m.programsData)
    m.taskCount--
    if m.taskCount = 0
      m.setField("content", m.timeGridContent)
      currentTime = CreateObject("roDateTime").asSeconds()
      m.contentStartTime = currentTime
      m.content = m.timeGridContent
      m.log.info("content for Epg", m.timeGridContent)
      m.state = "ready"
    end if
  end function

  private function onLoadResponse(result)
    m.log.method("onLoadResponse")

    if result.isOk
      m.content.appendChildren(result.data.getChildren(-1, 0))
    end if
    m.state = "ready"
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Public Method
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function onSelectedIndexChange(index)
    m.log.info("selected index", index)
    item = m.menuButtons[index]

    if item <> invalid

      screen = m.getScreen(item.target)

      if screen <> invalid
        m.setInstance("currentSelection", invalid)
        m.log.info("found screen for button, displaying it")
        m.focusIndex = index
        m.push(screen)
        m.setFocus(screen)
      else
        m.log.error("could not get the screen for", item.target)
      end if
    end if
  end function

  public function onFocusRow(index)

  end function

  public function onSelectItem(index)
    m.log.method("OnItemSelected")
    if m.content <> invalid and index <> -1
      currentTime = CreateObject("roDateTime").asSeconds()
      m.contentStartTime = currentTime + (86400 * index)
    end if
    m.isStyleUpdateRequired = true
  end function

  public function onProgramSelected(programIndex)
    if m.channelFocused <> -1
      m.log.info("onProgramSelected", programIndex)
      content = m.content.getChild(m.channelFocused)
      if content <> invalid
        program = content.getChild(programIndex)
        selection = m.createSelectionFromContent(program)
        selection.playMode = "default"
        mc.setOrAddNodeField(selection.initialItem, "itemType", "video")
        m.executeContentSelection(selection)
      end if
    end if
  end function

  public function onChannelFocused(channelIndex)
    m.log.info("onChannelFocused", channelIndex)
    m.channelFocused = channelIndex
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ style support
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function getChildCellStyle(componentJson as mc.types.assocarray)
    cellStyles = m.getInstance("cellStyles")
    key = asString(componentJson.styles.cell_style_key)
    if cellStyles.styleIdsByKey.doesExist(key)
      cellKey = cellStyles.styleIdsByKey[key]
      return cellStyles[cellKey]
    end if
    return invalid
  end function

  private function setRowStyle(content)
    m.log.method("setRowStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      listStyle = zapp.collectionRowUtils.getRowListStyle(m.riversJson.styles, cellStyle.normal)
      listStyle.itemSize = listStyle.rowItemSize
      m.listStyle = listStyle
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if

  end function

  private function stylingChannelItemComponent(styles)
    channelPoster = invalid
    channelPoster.height = styles.channel_asset_height
    channelPoster.height = styles.channel_asset_height
    channelPoster.backgroundColor = zapp.viewUtils.transposeUIBColor(styles["channel_background_color"])
    translation = [abs(styles.channel_padding_left - styles.channel_padding_right), abs(styles.channel_padding_top - styles.channel_padding_bottom)]
    channelPoster.translation = translation
  end function

  private function stylingDayLabelComponent(styles)
    localizedText = "aaaa"'zapp.viewUtils.getLocalizedText(control, localization)

    dayLabelText = zapp.viewUtils.textToTextTransformFormat(localizedText, styles.days_label_text_transform)
    dayLabelFont = zapp.viewUtils.makeUIBTextStyle(styles, "days_label")
    dayLabelSelected = zapp.viewUtils.makeUIBTextStyle(styles, "days_label_selected")
    m.listStyle = {
      translation: [abs(styles.days_tabs_padding_left - styles.days_tabs_padding_right), abs(styles.days_tabs_padding_top - styles.days_tabs_padding_bottom)]
      itemSpacing: [zapp.viewUtils.getUIBInt(styles, "days_tabs_horizontal_gutter", 15)]
      itemSize: zapp.viewUtils.makeUIBSize(styles, "item", 680, 80)
      vertFocusAnimationStyle: ""
      focusBitmapBlendColor: zapp.viewUtils.makeUIBTextStyle(styles, "days_label_focused")
      focusBitmapUri: zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    }
  end function

  private function stylingGridComponent(styles)
    grid = invalid
    grid.backgroundColor = zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    translation = [abs(styles.days_tabs_padding_left - styles.days_tabs_padding_right), abs(styles.days_tabs_padding_top - styles.days_tabs_padding_bottom)]
    grid.translation = translation
    grid.itemSpacings = [zapp.viewUtils.getUIBInt(styles, "grid_horizontal_gutter", 15)]
  end function

  private function setContentStyle(content)
    m.log.method("setContentStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ feed processing
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public override function onFeedResult(result)
    m.log.method("onFeedResult")
    m.toggleLoadingDataTask(false)

    if result.isOk
      m.isFirstLoadComplete = true
      m.setContentStyle(result.data)
      m.feed = result.data
      m.restoreSelection()
      m.state = "ready"
      m.content.json = m.feed.json
      m.content.title = m.feed.title
      m.content.id = m.feed.id
      m.setContentStyle(m.content)
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
    else
      m.onFeedError(invalid)
      m.content@.receiveRowData([])
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Private Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function updateFocusControls()
    m.focusIds = []
    'if m.button1.visible = true
    '  m.focusIds.push("button1")
    'end if
    'if m.button2.visible = true
    '  m.focusIds.push("button2")
    'end if
  end function

  private function updateButtons(styles as mc.types.assocarray)
    m.getLocalization()
    m.ascertainUsedButtons(styles)
    m.setButtonStyles(styles)
    m.setButtonsActions(styles)
  end function

  private function ascertainUsedButtons(styles)
    m.isUsingButtons = zapp.viewUtils.getUIBBool(styles, "tv_buttons_container_buttons_enabled")
    'm.controlsGroup.visible = m.isUsingButtons
    aaa = m.getMField("top")
    m.button1 = aaa.getChild(4).getChild(0)
    'm.dayButtonStyle = zapp.viewUtils.applyActionButtonStyle(m.button1, styles, "tv_buttons_button_1", m.localizations)
    'if m.isUsingButtons
    '  marginStyle = zapp.viewUtils.makeUIBMargin(styles, "tv_buttons_container")
    '  controlsGroupAligment = asString(styles.tv_buttons_container_align)
    '  controlsGroupPosition = asString(styles.tv_buttons_container_position)
    '  m.controlsGroup.itemSpacings = [zapp.viewUtils.getUIBInt(styles, "tv_buttons_container_horizontal_gutter", 15)]
    '  m.controlsGroup.translation = [abs(marginStyle.marginLeft - marginStyle.marginRight), abs(marginStyle.marginTop - marginStyle.marginBottom)]
    'end if

    if m.isUsingButtons
      m.button1.visible = zapp.viewUtils.getUIBBool(styles, "tv_buttons_button_1_button_enabled")
      'm.button2.visible = zapp.viewUtils.getUIBBool(styles, "tv_buttons_button_2_button_enabled")
    end if
  end function

  private function getLocalization()
    plugin = m.plugins.getPluginById("quick-brick-epg-screen")
    localization = asAA(plugin.json.configuration_json.localizations)
    language = m.getInstance("languageCode") ?? "en"
    m.localizations = localization[language]
  end function

  private function setButtonsActions(styles)
    mc.setOrAddNodeField(m.button1, "action", m.buttonActionMap[asString(styles.actionbuttonjson.tv_buttons_button_1_assign_action)])
    mc.setOrAddNodeField(m.button2, "action", m.buttonActionMap[asString(styles.actionbuttonjson.tv_buttons_button_2_assign_action)])
  end function

  private function setButtonStyles(styles)
    if m.checkIfIndependentStylesNeeded(styles)
      m.dayButtonStyle = zapp.viewUtils.applyActionButtonStyle(m.button1, styles, "tv_buttons_button_1", m.localizations)
      m.filterButtonStyle = zapp.viewUtils.applyActionButtonStyle(m.button2, styles, "tv_buttons_button_2", m.localizations)
    else
      m.setGeneralStyleForAllButtons(styles)
    end if
  end function

  private function checkIfIndependentStylesNeeded(styles)
    independentStyles = zapp.viewUtils.getUIBBool(styles.actionbuttonjson, "tv_buttons_container_independent_styles")
    if independentStyles
      return true
    end if
    return false
  end function

  private function setGeneralStyleForAllButtons(styles)
    aaa = m.getMField("top")
    m.controlsGroup = aaa.getChild(4)
    for i = 0 to m.controlsGroup.getChildCount() - 1
      if m.controlsGroup.getChild(i).visible
        for each item in m.controlsGroup.getChildren(-1, 0)
          prefix = m.convertItemIdToPrefix(m.controlsGroup.getChild(i).id)
          item.style = zapp.viewUtils.applyActionButtonStyle(item, styles, prefix, m.localizations)
          item.text = "aaaaaaaaaa"
        end for
        exit for
      end if
    end for
  end function

  private function convertItemIdToPrefix(id as string)
    if id = "button1"
      return "tv_buttons_button_1"
    else
      return "tv_buttons_button_2"
    end if
  end function


  private function makeEPGData(riversJsonData)
    m.setEpgContent(riversJsonData.data)
    m.isFirstLoadComplete = true
    return true
  end function

  private function setEpgStyle(styles)
    if styles <> invalid
      'm.stylingChannelItemComponent(styles)
      m.stylingDayLabelComponent(styles)
      'm.stylingGridComponent(styles)
    end if
  end function

  private function toggleUpdateTimer(active as boolean)
    m.log.info("toggleUpdateTimer is active ", active)
    if active
      m.timeout = m.waitAFrame(m.loadChangedContentOnTimeReason, 60)
    else
      m.cancelWaitTimer(m.timeout)
    end if
  end function

  private function loadChangedContentOnTimeReason()
    m.loadChangedContent("showOnTimer")
    m.toggleUpdateTimer(true)
  end function

  private function loadChangedContent(reason as string) as boolean
    if m.content@.isReloadRequired(reason)
      m.load()
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
      return true
    else
      return false
    end if
  end function

  private function parseDateStringToSeconds(dateString)
    if type(dateString) <> "roString" and type(dateString) <> "String"
      m.log.error("parseDateStringToSeconds: not a valid string")
      return 0
    end if
    if len(dateString) <> 24
      m.log.error("parseDateStringToSeconds: dateString is not in the expected format 'YYYY/MM/DD HH:MM:SS +zzzz'")
      return 0
    end if

    'Change to YYYY-MM-DD HH:MM:SS
    iso8601 = Left(dateString, 19)
    iso8601.replace("/", "-")
    zoneOffset = Right(dateString, 4)
    zoneOffsetHH = Left(zoneOffset, 2)
    zoneOffsetMM = Right(zoneOffset, 2)
    zoneOffsetSign = 1

    if dateString.instr(20, "+") > 0
      zoneOffsetSign = -1
    end if

    parsedDate = CreateObject("roDateTime")
    parsedDate.FromISO8601String(iso8601)
    parsedSeconds = parsedDate.AsSeconds()

    ' return integer seconds in GMT
    result = parsedSeconds + zoneOffsetSign * ((zoneOffsetHH.ToInt() * 3600) + (zoneOffsetMM.ToInt() * 60))
    return result
  end function

  private function substituteIdInUrl(url as string, id as integer) as string
    return url.replace("{{id}}", id)
  end function

  private function removingGridGap()
    topFields = m.getMField("top")
    topParant = topFields.getParent()
    for each child in topParant.getChildren(-1, 0)
      if child.id = m.getInstance("selectedId")
        childTranslationY = child.translation[1]
        gridTranslation = zapp.viewUtils.makeUIBPosition(m.riversJsonData.styles, "grid", 20, 20)
        if gridTranslation[1] <> 20 and childTranslationY > gridTranslation[1]
          child.translation = [m.gridStyle.translation[0], childTranslationY - gridTranslation[1]]
        end if
      end if
    end for
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Key Presses
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  override function onKeyPressUp() as boolean
    m.log.info("on Keypress up. focusId", m.focusId)
    if m.focusId = "timeGrid"
      m.log.info("was focused on terms button")
      m.setFocusId("controlsGroup")
      return true
    end if
    return false
  end function

  override function onKeyPressDown() as boolean
    m.log.info("onKeyPressDown", m.focusId)
    if m.focusId = "controlsGroup"
      m.log.info("focusing on button")
      m.setFocusId("timeGrid")
    end if
    return true
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ lifecycle
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  protected override function onShow() as void
    m.log.method("onShow", m.state)
    if m.state = "ready" or m.state = "initialized" or m.state = "error"
      if m.isFirstLoadComplete
        m.log.info("grid already loaded; code to manage reloadKey expiration is not yet implemented")

        'if m.loadChangedContent("showScreen")
        '  m.log.info("updating grid content")
        '  m.toggleUpdateTimer(true)
        'end if
        'm.removingGridGap()
      else
        m.log.info("this zapp.view has never loaded - trying now")
        m.load()
      end if
    end if
    m.restoreSelection()
  end function

  function restoreSelection()
    if m.selection <> invalid and m.content <> invalid and m.content.count() > 0

    end if
  end function

  public override function cancelLoad()
    m.log.method("cancelLoad")

    super.cancelLoad()

    'if m.loadMoreTask <> invalid
    '  m.cancelTask(m.loadMoreTask)
    '  m.loadMoreTask = invalid
    '  m.state = "ready"
    'end if

    m.isShowingLoadingSpinner = false
  end function

  protected override function onHide()
    m.toggleUpdateTimer(false)
  end function


end class