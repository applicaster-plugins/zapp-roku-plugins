import "pkg:/source/authorization/BaseAuthPlugin.bs"
import "pkg:/source/authorization/JWTUtil.bs"
import "pkg:/source/lib/BaseClass.bs"
import "pkg:/source/lib/APIUtils.bs"
import "pkg:/source/UIBuilder/view/Component.bs"
import "pkg:/source/zapp-controls/BaseCollectionRowVM.bs"
import "pkg:/source/lib/ViewUtils.bs"
import "pkg:/source/zapp-pipes/EntryLoader.bs"
import "pkg:/source/UIBuilder/view/ScreenVM.bs"

enum ButtonAction
  play = "play"
  info = "info"
  favorite = "favorite"
end enum

class QuickBrickEpgScreenVM extends zapp.uib.ScreenVM

  'styling
  public timeGridDayText = "Today"
  public filterLabelText = ""
  public menuButtons = []
  public titleTextStyle = {}
  public menuStyle = {}
  public menuPosition = [960, 584]
  public buttonSize = [700, 100]
  public buttonSpacing = 5
  public jumpToIndex = -1
  public isHeaderShown = false
  public isHeaderImageVisible = false
  public isHeaderImageVideoPlayback = false
  public isDetailsVisible = false
  public headerItem = invalid
  public headerStyle = invalid

  'public content = m.createSGNode("CollectionRow")
  public channelIndex = -1
  public programIndex = -1
  public channelFocused = 0
  public programFocused = 0
  public content = invalid
  public listStyle = {}
  public contentStartTime = {}
  public leftEdgeTargetTime = 0

  private jwtUtil = new zapp.JWTUtil()
  private canShowHeader = false
  private isHeaderUpdatingOnFocus = false
  private timeout = invalid
  private loadChannelTask = invalid
  private loadProgramTask = invalid
  private focusRectangle = invalid
  private channelItem = invalid
  private timeGridContent = invalid
  private timeGrid = invalid
  private contentLoader = new zapp.pipes.EntryLoader()

  private selectedIndexLabel = "now_label"
  private focusIds = []
  private riversJsonData = invalid
  private contentDepth = 1
  private taskCount = invalid
  private programsData = []
  private channelCount = invalid
  private programPlayStart = 0
  private focusIndex = 0
  private localizations = invalid
  private isUsingButtons = true
  private cellStyle

  private showAnim
  private hideAnim

  private plugin

  @inject("constants")
  private constants

  @injectClass("zapp.PluginManager")
  private plugins

  private customItems = []

  ' /**
  '  * @module QuickBrickEpgScreenVM
  '  * @description
  ' **/
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Overridden Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function new(riversJson)
    super(riversJson, "QuickBrickEpgScreenVM")
    m.setEpgStyle(riversJson.styles)
    m.focusId = "TimeGrid"
    m.timeGrid = m.getMField("TimeGrid")

    m.style = m.getChildCellStyle(riversJson)
    m.riversJsonData = riversJson
    m.contentDepth = zapp.viewUtils.getUIBInt(riversJson.styles, "data_depth", 1)
    m.createAnimations()
    m.getLocalization()
    m.updateButtons(riversJson.styles)
  end function

  public function onSelectedIndexChangeMenu(index)
    m.log.info("selected index", index)
    item = m.menuButtons[index]
    currentTime = CreateObject("roDateTime")
    currentDayIndex = currentTime.getDayOfWeek()

    if item <> invalid

      newIndex = item.index
      if index = 0
        dayDifference = 0
      else
        dayDifference = newIndex - currentDayIndex
      end if

      if dayDifference < 0
        dayDifference = abs(index - 7)
      end if

      targetTime = currentTime.asSeconds() + (86400 * dayDifference)

      m.leftEdgeTargetTime = targetTime
      m.content = m.timeGridContent
    end if
  end function

  public override function load()
    m.log.info("load epg screen")

    m.makeEPGData(m.riversJsonData)
    m.plugin = m.plugins.getPluginById("quick-brick-epg-screen")

    m.epgHardcodedStyle(m.riversJsonData.styles)
    m.updateHeaderStyle(m.riversJsonData.styles)
    m.updateFocusControls()
    m.state = "ready"
    if m.isHeaderUpdatingOnFocus
      m.headerItem = invalid
      'm.observeNodeField(m.screenState, "focusedEntry", m.onFocusEntry)
    else
      m.headerItem = m.screenState.originEntry
      m.isHeaderShown = m.canShowHeader
    end if
    return true
  end function

  public override function resetStyles(riversJson)
    m.log.method("resetStyles")
    super.resetStyles(riversJson)
    m.setEpgStyle(riversJson.styles)
    m.setContentStyle(m.feed)

    m.feed = m.feed
    ' m.waitAFrame(m.onReloadStyle, 5)
  end function

  public override function onFocusEntry(entry) as void
    m.log.info("onFocusEntry epg screen")

    if m.isHeaderUpdatingOnFocus = true
      m.headerItem = entry
    end if
    m.isHeaderShown = m.canShowHeader
  end function

  private function onShowHideAnimation(anim as mv.animations.AnimationBase, visible as boolean, animated as boolean)
    m.log.info("onShowHideAnimation epg screen")

    if animated
      anim.start()
    else
      anim.jumpToEnd()
    end if
  end function

  private function applyDataMap(feed as mc.types.node, style as mc.types.assocarray) as void
    m.log.info("applyDataMap epg screen")

    if style <> invalid

      if feed <> invalid
        dataSource = feed.getChild(0)
      else
        dataSource = invalid
      end if

      'm.applyDataMapToControls(style.dataMap, dataSource)
    end if

    if m.isFocused
      m.onGainedFocus(true)
    else
      m.focusRectangle.visible = false
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Content creating
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function createAnimations()
    'm.showAnim = new mv.animations.Move(m.backgroundDayRectangle, 0.1, [-700, 0], [0, 0])
    'm.hideAnim = new mv.animations.Move(m.backgroundDayRectangle, 0.3, [0, 0], [-700, 0])
  end function


  private function epgHardcodedStyle(style)
    m.log.info("set timeGrid style")

    plugin = m.plugin
    timeGrid = m.timeGrid
    timeGridGroup = m.getMField("TimeGridGroup")
    timeGrid.timeBarTwoLineLayout = true

    yPosition = plugin.getIntValue("time_grid_position_y", 500)
    xPosition = plugin.getIntValue("time_grid_margin_left", 0)

    timeGridHeight = plugin.getIntValue("time_grid_item_size", 125)
    timeGrid.clippingRect = [0, -50, 1920, 1920]
    timeGridGroup.translation = [xPosition, yPosition]
    timeGrid.numRows = plugin.getIntValue("time_grid_visible_row", 6)
    timeGrid.itemSize = [1920, timeGridHeight]
    timeGrid.focusBitmapUri = "pkg:/images/SearchFocusBackground2.9.png"

    programFontName = mc.getString(style, "label1_font_name", "medium")
    programFontSize = plugin.getIntValue("label1_font_size", 12)
    programRightPadding = plugin.getIntValue("grid_item_padding_right", 12)
    programLeftPadding = plugin.getIntValue("grid_item_padding_left", 12)

    timeGrid.programBackgroundBitmapUri = asString(style.guide_item_asset_background_uri, "pkg:/images/timeGridBackground.9.png")
    'timeGrid.programTitleFont = zapp.viewUtils.resolveUIBFont(programFontName, programFontSize)
    timeGrid.programTitleColor = zapp.viewUtils.transposeUIBColor(style.label1_live_font_color, "#FFFFFF")
    timeGrid.programTitleFocusedColor = zapp.viewUtils.transposeUIBColor(style.label1_live_focused_font_color, "#FFFFFF")
    timeGrid.programHorizMargin = programLeftPadding + programRightPadding

    timeBarTopPadding = plugin.getIntValue("time_bar_padding_top", 60)
    timeBarBottomPadding = plugin.getIntValue("time_bar_padding_bottom", 60)
    timebarFontSize = plugin.getIntValue("time_bar_label_font_size", 12)
    timebarFontName = mc.getString(style, "time_bar_label_font_name", "medium")

    timeGrid.pastTimeScreenBlendColor = "#3D80FF"
    timeGrid.timeBarBitmapUri = ":"
    timeGrid.timeBarHeight = timeBarBottomPadding + timeBarTopPadding
    timeGrid.timeLabelColor = zapp.viewUtils.transposeUIBColor(style.time_bar_label_font_color, "#FFFFFF")
    'timeGrid.timeLabelFont = zapp.viewUtils.resolveUIBFont(timebarFontName, timebarFontSize)

    timeGrid.channelInfoBackgroundBitmapUri = asString(style.channel_background_item_uri, "pkg:/images/timeGridBackground.9.png")
    timeGrid.channelInfoWidth = plugin.getIntValue("channel_list_width", 245)

    timeGrid.nowBarWidth = plugin.getIntValue("time_bar_badge_width", 10)
    timeGrid.nowBarBitmapUri = asString(style.time_bar_badge_item_uri)
    timeGrid.nowBarBlendColor = zapp.viewUtils.transposeUIBColor(style.time_bar_badge_background_color, "")
    timeGrid.nowBarOffset = plugin.getIntValue("time_bar_badge_padding_left", 0)


    timeGrid.nowNextMode = asBoolean(style.grid_item_show)
    timeGrid.nowBackgroundBitmapUri = asString(style.grid_item_live_background_color, "pkg:/images/timeGridBackground.9.png")
    timeGrid.nextBackgroundBitmapUri = asString(style.grid_item_future_background_color, "pkg:/images/timeGridBackground.9.png")
    timeGrid.programNowNextTimeColor = zapp.viewUtils.transposeUIBColor(style.grid_item_future_background_color, "#FFFFFF")
    timeGrid.programNowNextTimeFocusedColor = zapp.viewUtils.transposeUIBColor(style.grid_item_future_focused_background_color, "#FFFFFF")
    'timeGrid.programNowNextHorizMargin =
    'timeGrid.programNowNextTimeTitleGap =
    '
    timeGrid.duration = 12600
    timeGrid.sectionDividerTopOffset = 30
    timeGrid.scrollSpeed = 100
    timeGrid.overlayBitmapUri = ""
    timeGrid.vertFocusAnimationStyle = "floatingFocus"
  end function

  private function createContentFromItems(items)
    m.log.info("createContentFromItems")

    if not mc.isArray(items)
      return invalid
    end if

    entryWraper = createObject("roSGNode", "ZPEntry")
    for i = 0 to items.count() - 1
      entry = m.createSGNode("ZPEntry", entryWraper, items[i], {
        title: items[i].title
        json: {
          title: items[i].title
          selected: lCase(items[i].title) = lCase(m.selectedIndexLabel)
        }
      })
      mc.setOrAddNodeField(entry, "isSelected", lCase(items[i].title) = lCase(m.selectedIndexLabel))
    end for
    m.setListStyle(entryWraper)
    return entryWraper
  end function


  function onLeftEdgeTargetTime()
    dt = CreateObject("roDateTime")
    nowTime = dt.AsSeconds()
    dayInSecond = 86400
    startDay = nowTime - (dt.GetHours() * 60 + dt.getMinutes() - dt.GetTimeZoneOffset()) * 60
    endDay = startDay + dayInSecond
    dt.FromSeconds(m.TimeGrid.leftEdgeTargetTime - (dt.GetTimeZoneOffset() * 60))
    m.timeGridDayText = dt.GetWeekday()
    if m.TimeGrid.leftEdgeTargetTime < endDay
      m.timeGridDayText = "Today"
    end if
  end function

  private function setEpgContent(data)
    m.log.info("setEpgContent")

    if asString(data.channels_source.source) <> ""
      m.state = "loading"
      m.loadChannelTask = m.executeloadTaskWithUrl("1", m.onLoadMoreResponse, data.channels_source.source, 0)
    end if
  end function

  private function loadMore()
    m.log.method("loadMore")
    m.state = "loading"
  end function

  private function onLoadMoreResponse(result)
    m.log.method("onLoadMoreResponse")

    m.state = "ready"

    m.timeGridContent = CreateObject("roSGNode", "ContentNode")
    m.taskCount = 0
    m.channelCount = -1
    channelsData = result.data
    programUrl = m.riversJsonData.data.programs_source.source

    for each channelData in channelsData.getChildren(-1, 0)
      m.channelItem = m.timeGridContent.createChild("ContentNode")
      m.channelItem.title = channelData.title
      m.channelItem.HDSMALLICONURL = channelData.json.images.image_base
      actuallUrl = m.substituteIdInUrl(programUrl, channelData.id)
      m.taskCount++
      m.loadProgramTask = m.executeloadTaskWithUrl("1", m.onLoadProgramsResponse, actuallUrl, 0)
    end for
  end function

  private function onLoadProgramsResponse(result)
    m.log.method("onLoadProgramsResponse")
    m.programsData = []
    if result.isOk
      m.channelCount++
      programsData = result.data
      programsCount = programsData.getChildCount() - 1
      for each programData in programsData.getChildren(-1, 0)
        programItem = m.channelItem.createChild("ContentNode")
        programItem.PLAYSTART = m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programItem.PLAYDURATION = m.parseDateStringToSeconds(programData.json.extensions.end_time) - m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programItem.TITLE = programData.title
        programItem.id = programData.id
        programItem.genre = programData.json.genre
        programItem.shortDescriptionLine1 = programData.json.summary
        'programItem.HDSMALLICONURL = programData.json.images.image_base
        m.programsData.push(programItem)
      end for
      if m.channelCount = 0
        m.programPlayStart = m.programsData.[programsCount].PLAYSTART
      end if
    end if
    m.programsData.SortBy("PLAYSTART")
    m.timeGridContent.getChild(m.channelCount).appendChildren(m.programsData)
    m.taskCount--
    if m.taskCount = 0
      m.setField("content", m.timeGridContent)
      currentTime = CreateObject("roDateTime").asSeconds()
      m.contentStartTime = currentTime
      m.content = m.timeGridContent
      m.log.info("content for Epg", m.timeGridContent)
      m.state = "ready"
    end if

    m.createCustomItems()
    m.updateMenuItems()
  end function

  private function onLoadResponse(result)
    m.log.method("onLoadResponse")

    if result.isOk
      m.content.appendChildren(result.data.getChildren(-1, 0))
    end if
    m.state = "ready"
  end function

  function calculateDaysDifference(currentTimestamp as integer, targetTimestamp as integer) as integer
    timestampDifference = targetTimestamp - currentTimestamp
    daysDifference = timestampDifference / 86400
    daysDifference = m.customRoundUp(daysDifference)

    if daysDifference >= 8
      return daysDifference
    end if

    return daysDifference + 1
  end function

  function customRoundUp(value as float) as integer
    integerPart = Int(value)

    if value - integerPart > 0
      roundedValue = integerPart + 1
    else
      roundedValue = integerPart
    end if

    return roundedValue
  end function


  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Public Method
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function onProgramSelected(programIndex)
    m.log.info("onProgramSelected", programIndex)
    m.selectProgram(programIndex)
  end function

  public function onChannelFocused(channelIndex)
    m.log.info("onChannelFocused", channelIndex)
    m.channelFocused = channelIndex
  end function

  public function onProgramFocused(programIndex)
    m.log.info("onProgramFocused", programIndex)
    m.programFocused = programIndex
    'm.selectProgram(programIndex)
  end function

  private function selectProgram(programIndex)
    if m.channelFocused <> -1
      m.log.info("onProgramSelected", programIndex)
      content = m.content.getChild(m.channelFocused)
      if content <> invalid
        program = content.getChild(programIndex)
        'm.onFocusEntry(program)
        'selection = m.createSelectionFromContent(program)
        'selection.playMode = "default"
        'mc.setOrAddNodeField(selection.initialItem, "itemType", "video")
        'm.executeContentSelection(selection)
      end if
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ style support
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function updateHeaderStyle(styles)
    m.log.info("setHeroStyle")
    m.isHeaderShown = false
    m.canShowHeader = mc.getPath(styles, "header_is_shown", true)
    m.isHeaderUpdatingOnFocus = mc.getPath(styles, "header_update_on_focus", true)
    m.isDetailsVisible = m.canShowHeader and mc.getPath(styles, "header_text_is_shown", false)
    m.isHeaderImageVisible = m.canShowHeader and mc.getPath(styles, "header_image_is_shown", false)
    m.isHeaderImageVideoPlayback = mc.getPath(styles, "header_image_is_video_preview", true)
    'if m.isHeaderImageVideoPlayback
    '  m.getMField("contentGroup").videoTarget = m.getMField("headerControl").findNode("fadingBackgroundImage")
    'end if
    m.headerStyle = styles
  end function

  private function getChildCellStyle(componentJson as mc.types.assocarray)
    m.log.info("getChildCellStyle")

    cellStyles = m.getInstance("cellStyles")
    key = asString(componentJson.styles.cell_style_key)
    if cellStyles.styleIdsByKey.doesExist(key)
      cellKey = cellStyles.styleIdsByKey[key]
      return cellStyles[cellKey]
    end if
    return invalid
  end function

  private function setListStyle(content)
    m.log.method("setListStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      listStyle = zapp.collectionRowUtils.getRowListStyle(m.riversJson.styles, cellStyle.normal)
      listStyle.itemSize = listStyle.rowItemSize
      m.listStyle = listStyle
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if

  end function

  private function stylingChannelItemComponent(styles)
    channelPoster = invalid
    channelPoster.height = styles.channel_asset_height
    channelPoster.height = styles.channel_asset_height
    channelPoster.backgroundColor = zapp.viewUtils.transposeUIBColor(styles["channel_background_color"])
    translation = [abs(styles.channel_padding_left - styles.channel_padding_right), abs(styles.channel_padding_top - styles.channel_padding_bottom)]
    channelPoster.translation = translation
  end function

  private function stylingDayLabelComponent(styles)
    '// Will need to be implemented in the future scope
    localizedText = zapp.viewUtils.getLocalizedText("control", "localization")

    m.filterLabelText = "Filter Days"
    dayLabelText = zapp.viewUtils.textToTextTransformFormat(localizedText, styles.days_label_text_transform)
    dayLabelFont = zapp.viewUtils.makeUIBTextStyle(styles, "days_label")
    dayLabelSelected = zapp.viewUtils.makeUIBTextStyle(styles, "days_label_selected")

    marginStyle = zapp.viewUtils.makeUIBMargin(styles, "tv_buttons_container")

    marginTop = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_top")
    marginRight = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_right")
    marginBottom = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_bottom")
    marginLeft = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_left")

    m.listStyle = {
      translation: [abs(marginLeft - marginRight), abs(marginTop - marginBottom)]
      itemSpacing: [zapp.viewUtils.getUIBInt(styles, "days_tabs_horizontal_gutter", 15)]
      itemSize: zapp.viewUtils.makeUIBSize(styles, "item", 680, 80)
      vertFocusAnimationStyle: ""
      focusBitmapBlendColor: zapp.viewUtils.makeUIBTextStyle(styles, "days_label_focused")
      focusBitmapUri: zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    }
  end function

  private function stylingGridComponent(styles)
    grid = invalid
    grid.backgroundColor = zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    translation = [abs(styles.days_tabs_padding_left - styles.days_tabs_padding_right), abs(styles.days_tabs_padding_top - styles.days_tabs_padding_bottom)]
    grid.translation = translation
    grid.itemSpacings = [zapp.viewUtils.getUIBInt(styles, "grid_horizontal_gutter", 15)]
  end function

  private function setContentStyle(content)
    m.log.method("setContentStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ feed processing
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public override function onFeedResult(result)
    m.log.method("onFeedResult")
    m.toggleLoadingDataTask(false)

    if result.isOk
      m.isFirstLoadComplete = true
      m.setContentStyle(result.data)
      m.feed = result.data
      m.restoreSelection()
      m.state = "ready"
      m.content.json = m.feed.json
      m.content.title = m.feed.title
      m.content.id = m.feed.id
      m.setContentStyle(m.content)
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
    else
      m.onFeedError(invalid)
      m.content@.receiveRowData([])
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Private Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function updateFocusControls()
    itemGroup = []
    if m.isUsingButtons
      itemGroup.push("menu")
    end if
    itemGroup.push("TimeGrid")
    m.focusIds.push(itemGroup)
  end function

  private function updateButtons(styles as mc.types.assocarray)
    m.getLocalization()
    m.setButtonStyles(styles)
  end function

  private function getLocalization()
    m.plugin = m.plugins.getPluginById("quick-brick-epg-screen")

    localization = asAA(m.plugin.json.configuration_json.localizations)
    language = m.getInstance("languageCode") ?? "en"
    m.localizations = localization[language]
  end function

  private function setButtonStyles(styles)
    m.isUsingButtons = zapp.viewUtils.getUIBBool(styles, "epg_filter_button_enable")
    m.menuStyle = zapp.viewUtils.makeUIBButtonStyle(styles, "epg_filter_button", "custom", "")
    m.menuStyle.normal.delete("text")
    m.menuPosition = zapp.viewUtils.makeUIBPosition(styles, "epg_filter_button", 960, 200)
    m.buttonSize = zapp.viewUtils.makeUIBSize(styles, "epg_filter_button", 100, 100)
    m.buttonSpacing = zapp.viewUtils.getUIBInt(styles, "epg_filter_button_spacing", 5)
    mc.setOrAddNodeField(m.menuStyle, "layoutDirection", "horiz")
    m.titleTextStyle = zapp.viewUtils.makeUIBTextStyle(styles, "title")
  end function

  private function createCustomItems()
    m.customItems = []
    dataTime = CreateObject("roDateTime")
    nowTime = dataTime.asSeconds()
    currentDayIndex = dataTime.getDayOfWeek()
    '//Today Item
    item = m.createButton("button_1", 0)
    if item <> invalid
      m.customItems.push(item)
    end if

    days = m.calculateDaysDifference(nowTime, m.programPlayStart)

    for i = currentDayIndex + 1 to days + currentDayIndex
      numberText = str(i).trim()
      item = m.createButton("button_" + numberText, i - 1)
      if item <> invalid
        m.customItems.push(item)
      end if
    end for
  end function

  private function createButton(prefix, index)
    text = m.getLocalizeButtonText(prefix + "_title")
    text = zapp.viewUtils.textToTextTransformFormat(text, m.riversJsonData.styles.epg_filter_button_text_transform)
    'width = text.localBoundingRect().width
    if text <> invalid and text.trim() <> ""
      return {
        title: text
        index: index
      }
    end if

    return invalid
  end function

  private function getLocalizeButtonText(prefix as string)
    text = m.localizations[prefix]
    if text = invalid or text.trim() = ""
      text = m.riversJson.styles[prefix]
    end if
    return text
  end function

  private function updateMenuItems()
    m.log.info("updateMenuItems")

    items = []
    items.append(m.customItems)
    m.menuButtons = items
    m.jumpToIndex = 0
  end function

  private function makeEPGData(riversJsonData)
    m.setEpgContent(riversJsonData.data)
    m.isFirstLoadComplete = true
    return true
  end function

  private function setEpgStyle(styles)
    if styles <> invalid
      'm.stylingChannelItemComponent(styles)
      'm.stylingDayLabelComponent(styles)
      'm.stylingGridComponent(styles)
    end if
  end function

  private function toggleUpdateTimer(active as boolean)
    m.log.info("toggleUpdateTimer is active ", active)
    if active
      m.timeout = m.waitAFrame(m.loadChangedContentOnTimeReason, 60)
    else
      m.cancelWaitTimer(m.timeout)
    end if
  end function

  private function loadChangedContentOnTimeReason()
    m.loadChangedContent("showOnTimer")
    m.toggleUpdateTimer(true)
  end function

  private function loadChangedContent(reason as string) as boolean
    if m.content@.isReloadRequired(reason)
      m.load()
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
      return true
    else
      return false
    end if
  end function

  private function parseDateStringToSeconds(dateString)
    if type(dateString) <> "roString" and type(dateString) <> "String"
      m.log.error("parseDateStringToSeconds: not a valid string")
      return 0
    end if
    if len(dateString) <> 24
      m.log.error("parseDateStringToSeconds: dateString is not in the expected format 'YYYY/MM/DD HH:MM:SS +zzzz'")
      return 0
    end if

    'Change to YYYY-MM-DD HH:MM:SS
    iso8601 = Left(dateString, 19)
    iso8601.replace("/", "-")
    zoneOffset = Right(dateString, 4)
    zoneOffsetHH = Left(zoneOffset, 2)
    zoneOffsetMM = Right(zoneOffset, 2)
    zoneOffsetSign = 1

    if dateString.instr(20, "+") > 0
      zoneOffsetSign = -1
    end if

    parsedDate = CreateObject("roDateTime")
    parsedDate.FromISO8601String(iso8601)
    parsedSeconds = parsedDate.AsSeconds()

    ' return integer seconds in GMT
    result = parsedSeconds + zoneOffsetSign * ((zoneOffsetHH.ToInt() * 3600) + (zoneOffsetMM.ToInt() * 60))
    return result
  end function

  private function substituteIdInUrl(url as string, id as integer) as string
    return url.replace("{{id}}", id)
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Key Presses
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  override function onKeyPressUp() as boolean
    m.log.info("on Keypress up. focusId", m.focusId)
    if m.isDayMenuInFocus(m.focusId)
      zapp.appService.toggleNavMenuFocus(true)
    end if

    if not m.isDayMenuInFocus(m.focusId)
      m.setFocusId(m.focusIds[0][0])
    end if
    return true
  end function

  public function onKeyPressDown() as boolean
    m.log.info("onKeyPressDown", m.focusId)
    if m.isDayMenuInFocus(m.focusId)
      if m.isUsingButtons
        m.setFocusId(m.focusIds[0][1])
      else
        m.setFocusId(m.focusIds[0][0])
      end if
    end if

    return true
  end function

  private function isDayMenuInFocus(focusId)
    for i = 0 to m.focusIds[0].count() - 1
      if focusId = m.focusIds[0][0]
        return true
      end if
    end for
    return false
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ lifecycle
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  protected override function onShow() as void
    m.log.method("onShow", m.state)
    if m.state = "ready" or m.state = "initialized" or m.state = "error"
      if m.isFirstLoadComplete
        m.log.info("grid already loaded; code to manage reloadKey expiration is not yet implemented")

        'if m.loadChangedContent("showScreen")
        '  m.log.info("updating grid content")
        '  m.toggleUpdateTimer(true)
        'end if
        'm.removingGridGap()
      else
        m.log.info("this zapp.view has never loaded - trying now")
        m.load()
      end if
    end if
    m.restoreSelection()
  end function

  function restoreSelection()
    if m.selection <> invalid and m.content <> invalid and m.content.count() > 0

    end if
  end function

  public override function cancelLoad()
    m.log.method("cancelLoad")

    super.cancelLoad()

    'if m.loadMoreTask <> invalid
    '  m.cancelTask(m.loadMoreTask)
    '  m.loadMoreTask = invalid
    '  m.state = "ready"
    'end if

    m.isShowingLoadingSpinner = false
  end function

  protected override function onHide()
    m.toggleUpdateTimer(false)
  end function

end class