import "pkg:/source/authorization/BaseAuthPlugin.bs"
import "pkg:/source/authorization/JWTUtil.bs"
import "pkg:/source/lib/BaseClass.bs"
import "pkg:/source/lib/APIUtils.bs"
import "pkg:/source/UIBuilder/view/Component.bs"
import "pkg:/source/zapp-controls/BaseCollectionRowVM.bs"
import "pkg:/source/lib/ViewUtils.bs"
import "pkg:/source/zapp-pipes/EntryLoader.bs"
import "pkg:/source/UIBuilder/view/ScreenVM.bs"
import "pkg:/source/zapp-pipes/Parser.bs"

enum ButtonAction
  play = "play"
  info = "info"
  favorite = "favorite"
end enum

class QuickBrickEpgScreenVM extends zapp.uib.ScreenVM

  'styling
  public timeGridNowText = "Now"
  public timeGridNextText = "Next"
  public timeGridDayText = ""
  public timeGridDayVisible = false
  public filterLabelText = ""
  public menuButtons = []
  public titleTextStyle = {}
  public menuStyle = {}
  public menuPosition = [960, 584]
  public buttonSize = [700, 100]
  public indicatorVisible = false
  public indicatorOpacity = 1
  public indicatorTranslation = [0, 0]
  public buttonSpacing = 5
  public jumpToIndex = -1
  public isHeaderShown = false
  public isHeaderImageVisible = false
  public isHeaderImageVideoPlayback = false
  public isDetailsVisible = false
  public headerItem = invalid
  public headerStyle = invalid

  'public content = m.createSGNode("CollectionRow")
  public channelIndex = -1
  public programIndex = -1
  public channelFocused = 0
  public programFocused = 0
  public content = invalid
  public listStyle = {}
  public contentStartTime = {}
  public leftEdgeTargetTime = 0
  public isoTime = 0
  public nowIndicatorStyle = {}

  private jwtUtil = new zapp.JWTUtil()
  private nowIndicatorTimer as mc.types.node
  private todayContent = invalid
  private liveAsset = ""
  private isNowNextMode = false
  private dayInSeconds = 86400
  private canShowHeader = false
  private isHeaderUpdatingOnFocus = false
  private timeout = invalid
  private loadChannelTask = invalid
  private loadProgramTask = []
  private focusRectangle = invalid
  private channelItem = invalid
  private timeGridContent = invalid
  private timeGrid = invalid
  private buttonsIsReady = false
  private contentLoader = new zapp.pipes.EntryLoader()
  private cachedTimeGridValue = {}
  private programState = ""
  private currentTimeGridLeftEdgeTime = 0
  private parser = new zapp.pipes.Parser()

  private timeGridState = "loading"
  private regex = invalid
  private focusIds = []
  private riversJsonData = invalid
  private contentDepth = 1
  private taskCount = 0
  private programsData = []
  private channelCount = invalid
  private programPlayStart = 0
  private focusIndex = 0
  private localizations = invalid
  private isUsingButtons = true
  private cellStyle
  private dateTime

  private showAnim
  private hideAnim

  private plugin

  @inject("channelGuideItem")
  private channelGuideItem

  @inject("constants")
  private constants

  @injectClass("zapp.PluginManager")
  private plugins

  private customItems = []

  ' /**
  '  * @module QuickBrickEpgScreenVM
  '  * @description
  ' **/
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Overridden Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function new(riversJson)
    super(riversJson, "QuickBrickEpgScreenVM")
    m.plugin = m.plugins.getPluginById("quick-brick-epg-screen")

    m.focusId = "TimeGrid"
    m.timeGrid = m.getMField("TimeGrid")
    m.dateTime = CreateObject("roDateTime")

    m.style = m.getChildCellStyle(riversJson)
    m.riversJsonData = riversJson
    m.contentDepth = zapp.viewUtils.getUIBInt(riversJson.styles, "data_depth", 1)
    m.regex = CreateObject("roRegex", "\{\{([a-z_\-\.0-9]*)}\}", "gim")
    m.createAnimations()
    m.getLocalization()
    m.updateButtons(riversJson.styles)
  end function

  public override function load()
    m.log.info("load epg screen")

    m.makeEPGData(m.riversJsonData)
    m.epgHardcodedStyle(m.riversJsonData.styles)
    m.updateHeaderStyle(m.riversJsonData.styles)
    m.updateFocusControls()

    if m.isHeaderUpdatingOnFocus
      m.headerItem = invalid
      'm.observeNodeField(m.screenState, "focusedEntry", m.onFocusEntry)
    else
      m.headerItem = m.screenState.originEntry
      m.isHeaderShown = m.canShowHeader
    end if
    return true
  end function

  public override function resetStyles(riversJson)
    m.log.method("resetStyles")
    super.resetStyles(riversJson)
    m.setContentStyle(m.feed)

    m.feed = m.feed
    ' m.waitAFrame(m.onReloadStyle, 5)
  end function

  public override function onFocusEntry(entry) as void
    m.log.info("onFocusEntry epg screen")

    if m.isHeaderUpdatingOnFocus = true
      m.headerItem = entry
    end if
    m.isHeaderShown = m.canShowHeader
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Content creating
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function makeEPGData(riversJsonData)
    m.setIsoTime()
    m.setEpgContent(riversJsonData.data)
    m.isFirstLoadComplete = true
    return true
  end function

  private function setIsoTime(targetTimestamp = invalid)
    dataTime = CreateObject("roDateTime")
    if targetTimestamp <> invalid
      dataTime.FromSeconds(targetTimestamp)
    end if
    isoTime = dataTime.ToISOString("millseconds")
    m.isoTime = isoTime.replace("Z", `.${123}Z`)
  end function

  private function applyDataMap(feed as mc.types.node, style as mc.types.assocarray) as void
    m.log.info("applyDataMap epg screen")

    if style <> invalid

      if feed <> invalid
        dataSource = feed.getChild(0)
      else
        dataSource = invalid
      end if

      'm.applyDataMapToControls(style.dataMap, dataSource)
    end if

    if m.isFocused
      m.onGainedFocus(true)
    else
      m.focusRectangle.visible = false
    end if

  end function

  private function setEpgContent(data)
    m.log.info("setEpgContent")

    if asString(data.channels_source.source) <> ""
      m.state = "loading"
      m.timeGridState = "loading"
      m.loadChannelTask = m.executeloadTaskWithUrl("1", m.onLoadMoreResponse, data.channels_source.source, 0)
    end if
  end function

  private function loadMore()
    m.log.method("loadMore")
    m.state = "loading"
  end function

  private function onLoadMoreResponse(result)
    m.log.method("onLoadMoreResponse")

    if asBoolean(result.isOk)
      m.state = "ready"
      isoTime = m.isoTime
      m.timeGridContent = invalid
      m.timeGridContent = CreateObject("roSGNode", "ContentNode")
      m.taskCount = 0
      m.channelCount = -1
      channelsData = result.data
      programData = asAA(m.riversJsonData.data.programs_source)
      if channelsData <> invalid
        for each channelData in channelsData.getChildren(-1, 0)
          m.channelItem = m.timeGridContent.createChild("ContentNode")
          m.channelItem.title = channelData.title
          m.channelItem.HDSMALLICONURL = asString(channelData.json.images.image_base)
          actualUrl = m.substituteIdInUrl(programData.source, m.channelItem, channelData, asAA(programData.mapping), isoTime)
          id = asString(m.channelItem.id)
          m.taskCount++
          task = m.executeloadTaskWithUrlAndMapping(id, m.onLoadProgramsResponse, actualUrl, 0, "value", m.channelItem, programData)
          m.loadProgramTask.push(task)
        end for
      end if
    else
      m.log.error("Failed to load channels data")
      m.state = "error"
    end if
  end function

  private function getChannelId(timeGridContent, id)
    for each channel in timeGridContent.getChildren(-1, 0)
      if channel.id = id
        return channel
      end if
    end for
    return timeGridContent.getChild(0)
  end function

  private function onLoadProgramsResponse(result)
    m.log.method("onLoadProgramsResponse")
    m.programsData = []
    styles = m.riversJsonData.styles
    m.programState = "loading"
    m.timeGrid.channelNoDataText = "Loading..."
    if asBoolean(result.isOk)
      m.channelCount++
      programsData = result.data
      programsCount = programsData.getChildCount() - 1
      for each programData in programsData.getChildren(-1, 0)
        channelItem = m.getChannelId(m.timeGridContent, result.id)
        programItem = channelItem.createChild("ContentNode")
        programItem.PLAYSTART = m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programItem.PLAYDURATION = m.parseDateStringToSeconds(programData.json.extensions.end_time) - m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programText = zapp.viewUtils.textToTextTransformFormat(programData.title, styles.label1_text_transform)
        programItem.TITLE = programText
        mc.setOrAddNodeField(programItem, "content", programData.json.content)
        mc.setOrAddNodeField(programItem, "type", programData.json.type)
        programItem.id = programData.id
        'programItem.genre = asString(programData.json.genre)
        programItem.shortDescriptionLine1 = asString(programData.json.summary)
        'programItem.HDSMALLICONURL = "pkg:/images/playButton.png"
        m.programsData.push(programItem)
      end for
      if m.channelCount = 0 and programsCount > 0
        m.programPlayStart = m.programsData.[programsCount].PLAYSTART
      end if
    end if
    m.programsData.SortBy("PLAYSTART")

    foundChildIndex = -1
    numChildren = m.timeGridContent.getChildCount()
    for i = 0 to numChildren - 1
      childNode = m.timeGridContent.getChild(i)
      if childNode <> invalid and childNode.id = asString(result.data.id)
        foundChildIndex = i
        exit for
      end if
    end for

    if foundChildIndex <> -1
      m.timeGridContent.getChild(foundChildIndex).appendChildren(m.programsData)
    end if
    m.taskCount--

    m.applyDataOnTaskComplete()

    if m.isUsingButtons and not m.isNowNextMode and not m.buttonsIsReady
      m.createCustomItems()
      m.updateMenuItems()
    end if
  end function

  private function applyDataOnTaskComplete()
    if m.leftEdgeTargetTime = 0 and m.todayContent = invalid and m.taskCount = 0
      m.todayContent = m.timeGridContent
    end if
    m.setField("content", m.timeGridContent)
    currentTime = CreateObject("roDateTime").asSeconds()
    m.contentStartTime = currentTime - 1200
    m.currentTimeGridLeftEdgeTime = m.contentStartTime
    m.content = m.timeGridContent
    m.log.info("content for Epg", m.timeGridContent)
    numRows = zapp.viewUtils.getUIBInt(m.riversJsonData.styles, "time_grid_visible_row", 6)
    channelCount = m.timeGridContent.getChildCount()
    if channelCount < numRows
      m.timeGrid.numRows = channelCount
    end if

    m.setNowBarIndicatorPosition()
    if m.taskCount = 0
      m.timeGrid.channelNoDataText = "No Data Available"
      m.waitAFrame(m.allDataLoaded, 0.2)
    end if
    m.state = "ready"
    m.programState = "ready"
  end function

  private function allDataLoaded()
    m.log.method("allDataLoaded")
    m.timeGridState = "ready"
  end function

  private function setNowBarIndicatorPosition()
    m.log.method("setNowBarIndicatorPosition")
    m.cancelInterval(m.nowIndicatorTimer)
    m.nowIndicatorTimer = invalid

    cachedTimeGridValue = m.cachedTimeGridValue
    yPosition = cachedTimeGridValue.yPosition
    pixelPerSecond = cachedTimeGridValue.pixelPerSecond
    xPosition = cachedTimeGridValue.xPosition

    currentTime = CreateObject("roDateTime").asSeconds()
    timeDiff = abs(m.currentTimeGridLeftEdgeTime - currentTime)

    indicatorXpos = timeDiff * pixelPerSecond
    m.indicatorTranslation = [m.customRoundUp(indicatorXpos) + xPosition, yPosition]

    m.nowIndicatorTimer = m.setInterval(m.setNowBarIndicatorPosition, 15)
  end function

  private function onLoadResponse(result)
    m.log.method("onLoadResponse")

    if asBoolean(result.isOk)
      m.content.appendChildren(result.data.getChildren(-1, 0))
    end if
    m.state = "ready"
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Public Method
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function onProgramSelected(programIndex)
    m.log.info("onProgramSelected", programIndex)
    m.selectProgram(programIndex)
  end function

  public function onChannelFocused(channelIndex) as void
    m.log.info("onChannelFocused", channelIndex)
    if m.programFocused < 0 and channelIndex = 0 and m.timeGridState = "loading"
      m.timeGrid.jumpToChannel = m.channelFocused
      return
    end if
    m.channelFocused = channelIndex
  end function

  public function onProgramFocused(programIndex)
    m.log.info("onProgramFocused", programIndex)
    m.programFocused = programIndex
    m.waitAFrame(m.changingCurrentDayLabel, 0.1)
    'm.selectProgram(programIndex)
  end function

  public function onSelectedIndexChangeMenu(index)
    m.log.info("selected index", index)
    item = m.menuButtons[index]

    for each task in m.loadProgramTask
      task.control = "stop"
    end for

    if item <> invalid
      m.loadProgramTask = []
      if index = 0 and m.todayContent <> invalid
        m.leftEdgeTargetTime = 0
        m.setField("content", invalid)
        m.content = m.todayContent
        m.timeGridContent = invalid
        m.timeGridContent = m.todayContent
        m.applyDataOnTaskComplete()
        m.timeGrid.jumpToTime = 0
      else
        currentTime = CreateObject("roDateTime")
        if index = 0
          targetTime = currentTime.asSeconds()
          m.leftEdgeTargetTime = 0
        else
          dayDifference = index
          timezone = currentTime.GetTimeZoneOffset() * 60
          hours = currentTime.GetHours() * 3600
          minutes = currentTime.GetMinutes() * 60
          targetTime = currentTime.asSeconds() + (m.dayInSeconds * dayDifference) - hours - minutes + timezone
          m.leftEdgeTargetTime = targetTime
        end if
        m.setIsoTime(int(targetTime))
        m.setEpgContent(m.riversJsonData.data)
      end if
    end if
  end function

  function changingCurrentDayLabel()
    dt = m.dateTime
    dt.mark()
    nowTime = dt.AsSeconds()
    dayInSecond = m.dayInSeconds
    startDay = nowTime - (dt.GetHours() * 60 + dt.getMinutes() - dt.GetTimeZoneOffset()) * 60
    endDay = startDay + dayInSecond
    i = m.channelFocused
    j = m.programFocused
    if i <> -1 and j <> -1
      focusedItem = m.timeGridContent.getChild(i).getChild(j)
      if focusedItem <> invalid and focusedItem.PLAYSTART + 100 > endDay
        dt.FromSeconds(focusedItem.PLAYSTART + 100 - (dt.GetTimeZoneOffset() * 60))
        dayOfTheWeek = dt.GetDayOfWeek()
        index = m.getDayLocalizationIndex(dayOfTheWeek)
        m.timeGridDayText = mc.getPath(m.localizations, `button_${index}_title`, dt.GetWeekday())
      else
        m.timeGridDayText = asString(m.localizations.button_1_title, "Today")
      end if
    end if
  end function

  function getDayLocalizationIndex(dayOfWeek as integer) as integer
    dayMapping = {
      "0": 8, ' Sunday -> button_8_title
      "1": 2, ' Monday -> button_2_title
      "2": 3, ' Tuesday -> button_3_title
      "3": 4, ' Wednesday -> button_4_title
      "4": 5, ' Thursday -> button_5_title
      "5": 6, ' Friday -> button_6_title
      "6": 7 ' Saturday -> button_7_title
    }
    key = dayOfWeek.tostr()

    if dayMapping.DoesExist(key)
      return dayMapping[key]
    else
      return 1 ' Default to Today (button_1_title)
    end if
  end function

  function onLeftEdgeTargetTime()
    now = CreateObject("roDateTime").asSeconds()
    content = m.timeGrid.content
    m.checkIndicatorVisibleOnLeftEdgeChange(now)
    if content <> invalid
      for i = 0 to content.getChildCount() - 1
        channel = content.getChild(i)
        for j = 0 to channel.getChildCount() - 1
          program = channel.getChild(j)
          playEnd = program.playStart + program.playDuration
          program.HDSMALLICONURL = ""
          if program.playStart < now and playEnd > now
            program.HDSMALLICONURL = m.liveAsset
            exit for
          end if
        end for
      end for
    end if

  end function

  private function checkIndicatorVisibleOnLeftEdgeChange(nowTime)
    m.currentTimeGridLeftEdgeTime = m.TimeGrid.leftEdgeTargetTime
    if m.TimeGrid.leftEdgeTargetTime - 10 > nowTime
      m.indicatorVisible = false
    else
      m.setNowBarIndicatorPosition()
      m.indicatorVisible = true
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ style support
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function epgHardcodedStyle(style)
    m.log.info("set timeGrid style")

    plugin = m.plugin
    if asAA(plugin.json.configuration_json).count() = 0
      plugin.json = {
        "configuration_json": {}
      }
    end if
    plugin.json.configuration_json.append(style)
    timeGrid = m.timeGrid
    timeGridGroup = m.getMField("TimeGridGroup")

    m.timeGridOverallSettings(timeGrid, timeGridGroup, plugin, style)
    m.defaultValues(timeGrid, plugin, style)
    m.nowNextSection(timeGrid, plugin, style)
    m.programItemSection(timeGrid, plugin, style)
    m.channelInfoSection(timeGrid, plugin, style)
    m.timeBarSection(timeGrid, plugin, style)
    m.nowBarSection(timeGrid, plugin, style)
    m.setNowBarIndicatorStyle(timeGrid, plugin, style)
  end function

  private function setNowBarIndicatorStyle(timeGrid, plugin, style)
    contentWidth = timeGrid.itemSize[0] - timeGrid.channelInfoWidth
    nowBarBadgeYposition = plugin.getIntValue("time_bar_indicator_y", 0)

    m.cachedTimeGridValue = {
      "yPosition": nowBarBadgeYposition - 50
      "contentWidth": timeGrid.itemSize[0] - timeGrid.channelInfoWidth
      "pixelPerSecond": contentWidth / timeGrid.duration
      "xPosition": timeGrid.channelInfoWidth
    }

    timebarFontSize = plugin.getIntValue("time_bar_badge_label_font_size", 12)
    timebarFontName = mc.getString(style, "time_bar_badge_label_font_name", "medium")
    fontColor = zapp.viewUtils.transposeUIBColor(style.time_bar_badge_label_font_color, "#FFFFFF")
    font = m.resolveFont(timebarFontName, timebarFontSize)
    nowBarWidth = plugin.getIntValue("time_bar_badge_width", 2)
    nowBarHeight = plugin.getIntValue("time_bar_badge_height", 500)
    nowBarBadgeWidth = plugin.getIntValue("time_bar_now_badge_width", 70)
    nowBarBadgeHeight = plugin.getIntValue("time_bar_now_badge_height", 35)
    nowBarLabelBadgeBackground = zapp.viewUtils.getPosterUri(asString(style.time_bar_now_badge_background_url), "pkg:/images/nowIndicator.9.png", "nowBarLabelBadge")
    nowBarText = asString(m.localizations.now_label_text, "Now")

    nowBarBlendColor = zapp.viewUtils.transposeUIBColor(style.time_bar_badge_background_color, "")
    verticalTimelineColor = zapp.viewUtils.transposeUIBColor(style.time_bar_badge_vertival_background_color, "#808080")

    style = {
      "fontColor": fontColor
      "font": font
      "nowBarText": nowBarText
      "nowBarBadgeWidth": nowBarBadgeWidth
      "nowBarBadgeHeight": nowBarBadgeHeight
      "nowBarWidth": nowBarWidth
      "nowBarLabelBadgeBackground": nowBarLabelBadgeBackground
      "nowBarHeight": nowBarHeight
      "verticalTimelineColor": verticalTimelineColor
      "nowBarBlendColor": nowBarBlendColor
    }
    m.nowIndicatorStyle = style
  end function

  private function defaultValues(timeGrid, plugin, style)

    if asBoolean(style.grid_item_show)
      m.isNowNextMode = true
      m.timeGridDayVisible = false
      rightOffset = plugin.getIntValue("time_grid_margin_right", 0)
      timeGrid.itemSize = [timeGrid.itemSize[0] - rightOffset, timeGrid.itemSize[1]]
      m.indicatorOpacity = 0
      m.timeGridDayText = ""
      timeGrid.clippingRect = [0, -100, 1920, 1920]
    else
      m.isNowNextMode = false
      timeGrid.timeBarTwoLineLayout = true
      timeGrid.clippingRect = [0, -50, 1920, 1920]
    end if
    defaultDuration = 7200
    timeGrid.duration = defaultDuration
    timeGrid.sectionDividerTopOffset = 30
    timeGrid.scrollSpeed = 100
    timeGrid.overlayBitmapUri = ""
    timeGrid.fillProgramGaps = true
    timeGrid.vertFocusAnimationStyle = "floatingFocus"
  end function

  private function timeGridOverallSettings(timeGrid, timeGridGroup, plugin, style)
    yPosition = plugin.getIntValue("time_grid_position_y", 500)
    xPosition = plugin.getIntValue("time_grid_margin_left", 0)

    timeGridHeight = plugin.getIntValue("time_grid_item_size", 125)
    timeGridGroup.translation = [xPosition, yPosition]
    timeGrid.numRows = plugin.getIntValue("time_grid_visible_row", 6)
    timeGrid.itemSize = [1920 - xPosition, timeGridHeight]
    timeGrid.focusBitmapUri = "pkg:/images/SearchFocusBackground2.9.png"
  end function

  private function programItemSection(timeGrid, plugin, style)
    programFontName = mc.getString(style, "label1_font_name", "medium")
    programFontSize = plugin.getIntValue("label1_font_size", 12)
    programRightPadding = plugin.getIntValue("grid_item_padding_right")
    programLeftPadding = plugin.getIntValue("grid_item_padding_left")
    horizontalGutter = plugin.getIntValue("grid_horizontal_gutter", 6)
    verticalGutter = plugin.getIntValue("grid_vertical_gutter")

    m.liveAsset = zapp.viewUtils.getPosterUri(asString(style.grid_item_live_asset), "pkg:/images/$$RES$$/grid-screen-mask.png", "liveAsset")

    timeGrid.iconColor = zapp.viewUtils.transposeUIBColor(style.grid_item_asset_color, "#FFFFFF")
    timeGrid.iconFocusedColor = zapp.viewUtils.transposeUIBColor(style.grid_item_asset_focused_color, "#808080")
    timeGrid.itemSpacing = [horizontalGutter, verticalGutter]
    if m.isNowNextMode
      timeGrid.programBackgroundBitmapUri = "empty"
    else
      timeGrid.programBackgroundBitmapUri = asString(style.guide_item_asset_background_uri, "pkg:/images/timeGridBackground.9.png")
    end if
    timeGrid.focusBitmapBlendColor = zapp.viewUtils.transposeUIBColor(style.program_background_color, "#FFFFFF")
    timeGrid.programTitleColor = zapp.viewUtils.transposeUIBColor(style.label1_live_font_color, "#FFFFFF")
    timeGrid.programTitleFocusedColor = zapp.viewUtils.transposeUIBColor(style.label1_live_focused_font_color, "#FFFFFF")
    timeGrid.programHorizMargin = programLeftPadding + programRightPadding
    timeGrid.programTitleFont = m.resolveFont(programFontName, programFontSize)
  end function



  private function timeBarSection(timeGrid, plugin, style)
    titleDayLabel = m.getMField("titleLabel")
    nowLabel = m.getMField("NowLabel")
    nextLabel = m.getMField("NextLabel")
    localizations = m.localizations

    timeBarTopPadding = plugin.getIntValue("time_bar_padding_top")
    timeBarBottomPadding = plugin.getIntValue("time_bar_padding_bottom")
    timeBarLeftPadding = plugin.getIntValue("time_bar_padding_left")

    timeBarTitleVisible = plugin.getBoolValue("time_bar_show", true)
    nowTextVisible = plugin.getBoolValue("time_bar_now_show", true)
    nextTextVisible = plugin.getBoolValue("time_bar_next_show", true)

    timebarFontSize = plugin.getIntValue("time_bar_label_font_size", 12)
    timebarFontName = mc.getString(style, "time_bar_label_font_name", "medium")

    timeGrid.pastTimeScreenBlendColor = "#3D80FF"
    timeGrid.timeLabelOffset = timeBarLeftPadding
    timeGrid.timeBarBitmapUri = asString(style.time_bar_background_url, ":")
    timeGrid.timeBarHeight = timebarFontSize + 140 - timeBarTopPadding + timeBarBottomPadding
    clippingY = timeGrid.clippingRect.y
    halfTimeBar = timeGrid.timeBarHeight / 2
    percentOfOffset = halfTimeBar / abs(clippingY)

    if halfTimeBar - timebarFontSize >= abs(clippingY)
      timeGrid.clippingRect = [0, clippingY * percentOfOffset - 20, 1920, 1920]
    end if
    fontColor = zapp.viewUtils.transposeUIBColor(style.time_bar_label_font_color, "#FFFFFF")
    font = m.resolveFont(timebarFontName, timebarFontSize)


    timeGrid.timeLabelColor = m.isNowNextMode ?"#FFFFFF00" : fontColor
    timeGrid.timeLabelFont = font
    titleDayLabel.color = fontColor
    titleDayLabel.font = font
    m.timeGridDayVisible = timeBarTitleVisible and not m.isNowNextMode

    nowLabel.color = fontColor
    nowLabel.font = font
    nowLabel.visible = nowTextVisible and m.isNowNextMode
    m.timeGridNowText = asString(localizations.now_label_text, "Now")
    channelListWidth = plugin.getIntValue("channel_list_width", 245)
    nowLabel.translation = [channelListWidth + 10, -59]

    nextLabel.color = fontColor
    nextLabel.font = font
    nextLabel.visible = nextTextVisible and m.isNowNextMode
    m.timeGridNextText = asString(localizations.next_label_text, "Next")
    channelListWidth = timeGrid.channelInfoWidth
    position = (timeGrid.itemSize[0] - channelListWidth) / 2 + channelListWidth
    nextLabel.translation = [position + 10, -59]
  end function

  private function resolveFont(programFontName, programFontSize)
    headerFont = CreateObject("roSGNode", "Font")
    font = invalid

    language = m.getInstance("languageCode") ?? "en"
    runtimeFonts = m.getInstance("runtimeFonts") ?? []
    programFontName = zapp.viewUtils.getTargetLanguageFontName(programFontName, language, runtimeFonts)
    labelFontPath = zapp.viewUtils.getLabelFontPath(programFontName, language, font)

    if labelFontPath.startsWith("pkg:/") or labelFontPath.startsWith("tmp:/")
      headerFont.uri = labelFontPath
      headerFont.size = programFontSize
    else
      font = labelFontPath
    end if

    if font <> invalid
      return font
    else
      return headerFont
    end if
  end function

  private function channelInfoSection(timeGrid, plugin, style)
    channelAssetHeight = plugin.getIntValue("channel_asset_height")
    channelPaddingTop = plugin.getIntValue("channel_padding_top")
    channelPaddingRight = plugin.getIntValue("channel_padding_right")
    channelPaddingBottom = plugin.getIntValue("channel_padding_bottom")
    channelPaddingLeft = plugin.getIntValue("channel_padding_left")
    channelAssetAspectRatio = plugin.getStringValue("channel_asset_aspect_ratio")
    channelCustomAssetAspectRatio = plugin.getStringValue("channel_asset_aspect_ratio_custom")
    timeGridHeight = plugin.getIntValue("time_grid_item_size", 125)
    channelInfoWidth = plugin.getIntValue("channel_list_width", 245)


    m.channelGuideItem.channelGuideSettings = {
      "channelAssetHeight": channelAssetHeight
      "channelPaddingTop": channelPaddingTop
      "channelPaddingRight": channelPaddingRight
      "channelPaddingBottom": channelPaddingBottom
      "channelPaddingLeft": channelPaddingLeft
      "channelAssetAspectRatio": channelAssetAspectRatio
      "channelCustomAssetAspectRatio": channelCustomAssetAspectRatio
      "channelInfoWidth": channelInfoWidth
      "channelInfoHeight": timeGridHeight
    }

    channelInfoBackgroundBitmapUri = asString(style.channel_background_item_uri, "pkg:/images/timeGridBackground.9.png")
    if channelInfoBackgroundBitmapUri = ""
      timeGrid.channelInfoBackgroundBitmapUri = "pkg:/images/timeGridBackground.9.png"
    else
      timeGrid.channelInfoBackgroundBitmapUri = channelInfoBackgroundBitmapUri
    end if
    timeGrid.channelInfoWidth = channelInfoWidth
  end function

  private function nowBarSection(timeGrid, plugin, style)
    timeGrid.nowBarWidth = plugin.getIntValue("time_bar_badge_width", 10)
    timeGrid.nowBarBitmapUri = "empty"
    timeGrid.nowBarBlendColor = zapp.viewUtils.transposeUIBColor(style.time_bar_badge_background_color, "")
    timeGrid.nowBarOffset = plugin.getIntValue("time_bar_badge_padding_left")
  end function

  private function nowNextSection(timeGrid, plugin, style)
    timeGrid.nowNextMode = asBoolean(style.grid_item_show)

    nowBackgroundBitmapUri = asString(style.grid_item_live_background_url) <> "" ? asString(style.grid_item_live_background_url) : "pkg:/images/timeGridBackground.9.png"
    nextBackgroundBitmapUri = asString(style.grid_item_live_focused_background_url) <> "" ? asString(style.grid_item_live_focused_background_url) : "pkg:/images/timeGridBackground.9.png"
    timeGrid.nowBackgroundBitmapUri = nowBackgroundBitmapUri
    timeGrid.nextBackgroundBitmapUri = nextBackgroundBitmapUri
    timeGrid.programNowNextTimeColor = zapp.viewUtils.transposeUIBColor(style.grid_item_future_background_color, "#FFFFFF")
    timeGrid.programNowNextTimeFocusedColor = zapp.viewUtils.transposeUIBColor(style.grid_item_future_focused_background_color, "#FFFFFF")
    timeGrid.programNowNextHorizMargin = zapp.viewUtils.getUIBInt(style, "grid_item_now_next_offset", 21)
    timeGrid.programNowNextTimeTitleGap = zapp.viewUtils.getUIBInt(style, "grid_item_now_next_title_gap", 22)
  end function

  private function updateHeaderStyle(styles)
    m.log.info("setHeroStyle")
    m.isHeaderShown = false
    m.canShowHeader = mc.getPath(styles, "header_is_shown", true)
    m.isHeaderUpdatingOnFocus = mc.getPath(styles, "header_update_on_focus", true)
    m.isDetailsVisible = m.canShowHeader and mc.getPath(styles, "header_text_is_shown", false)
    m.isHeaderImageVisible = m.canShowHeader and mc.getPath(styles, "header_image_is_shown", false)
    m.isHeaderImageVideoPlayback = mc.getPath(styles, "header_image_is_video_preview", true)
    'if m.isHeaderImageVideoPlayback
    '  m.getMField("contentGroup").videoTarget = m.getMField("headerControl").findNode("fadingBackgroundImage")
    'end if
    m.headerStyle = styles
  end function

  private function getChildCellStyle(componentJson as mc.types.assocarray)
    m.log.info("getChildCellStyle")

    cellStyles = m.getInstance("cellStyles")
    key = asString(componentJson.styles.cell_style_key)
    if cellStyles.styleIdsByKey.doesExist(key)
      cellKey = cellStyles.styleIdsByKey[key]
      return cellStyles[cellKey]
    end if
    return invalid
  end function

  private function setListStyle(content)
    m.log.method("setListStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      listStyle = zapp.collectionRowUtils.getRowListStyle(m.riversJson.styles, cellStyle.normal)
      listStyle.itemSize = listStyle.rowItemSize
      m.listStyle = listStyle
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if

  end function

  private function stylingDayLabelComponent(styles)
    '// Will need to be implemented in the future scope
    localizedText = zapp.viewUtils.getLocalizedText("control", "localization")

    m.filterLabelText = "Filter Days"
    dayLabelText = zapp.viewUtils.textToTextTransformFormat(localizedText, styles.days_label_text_transform)
    dayLabelFont = zapp.viewUtils.makeUIBTextStyle(styles, "days_label")
    dayLabelSelected = zapp.viewUtils.makeUIBTextStyle(styles, "days_label_selected")

    marginStyle = zapp.viewUtils.makeUIBMargin(styles, "tv_buttons_container")

    marginTop = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_top")
    marginRight = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_right")
    marginBottom = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_bottom")
    marginLeft = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_left")

    m.listStyle = {
      translation: [abs(marginLeft - marginRight), abs(marginTop - marginBottom)]
      itemSpacing: [zapp.viewUtils.getUIBInt(styles, "days_tabs_horizontal_gutter", 15)]
      itemSize: zapp.viewUtils.makeUIBSize(styles, "item", 680, 80)
      vertFocusAnimationStyle: ""
      focusBitmapBlendColor: zapp.viewUtils.makeUIBTextStyle(styles, "days_label_focused")
      focusBitmapUri: zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    }
  end function

  private function stylingGridComponent(styles)
    grid = invalid
    grid.backgroundColor = zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    translation = [abs(styles.days_tabs_padding_left - styles.days_tabs_padding_right), abs(styles.days_tabs_padding_top - styles.days_tabs_padding_bottom)]
    grid.translation = translation
    grid.itemSpacings = [zapp.viewUtils.getUIBInt(styles, "grid_horizontal_gutter", 15)]
  end function

  private function setContentStyle(content)
    m.log.method("setContentStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if
  end function

  private function setButtonStyles(styles)
    m.isUsingButtons = zapp.viewUtils.getUIBBool(styles, "epg_filter_button_enable") and not asBoolean(styles.grid_item_show)
    m.menuStyle = zapp.viewUtils.makeUIBButtonStyle(styles, "epg_filter_button", "custom", "")
    m.menuStyle.normal.delete("text")
    m.menuPosition = zapp.viewUtils.makeUIBPosition(styles, "epg_filter_button", 960, 200)
    m.buttonSize = zapp.viewUtils.makeUIBSize(styles, "epg_filter_button", 100, 100)
    m.buttonSpacing = zapp.viewUtils.getUIBInt(styles, "epg_filter_button_spacing", 5)
    mc.setOrAddNodeField(m.menuStyle, "layoutDirection", "horiz")
    m.titleTextStyle = zapp.viewUtils.makeUIBTextStyle(styles, "title")
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ feed processing
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public override function onFeedResult(result)
    m.log.method("onFeedResult")
    m.toggleLoadingDataTask(false)

    if asBoolean(result.isOk)
      m.isFirstLoadComplete = true
      m.setContentStyle(result.data)
      m.feed = result.data
      m.restoreSelection()
      m.state = "ready"
      m.content.json = m.feed.json
      m.content.title = m.feed.title
      m.content.id = m.feed.id
      m.setContentStyle(m.content)
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
    else
      m.onFeedError(invalid)
      m.content@.receiveRowData([])
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Private Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function getLiveProgramIndexForChannel(channel)
    now = CreateObject("roDateTime").AsSeconds()
    for j = 0 to channel.getChildCount() - 1 step 1
      program = channel.getChild(j)
      playEnd = program.playStart + program.playDuration
      if program.playStart < now and playEnd > now
        return j
        exit for
      end if
    end for
    return 0
  end function

  private function calculateDaysDifference(currentTimestamp as integer, targetTimestamp as integer) as integer
    timestampDifference = targetTimestamp - currentTimestamp
    daysDifference = timestampDifference / m.dayInSeconds
    daysDifference = m.customRoundUp(daysDifference)

    if daysDifference >= 8
      return daysDifference
    end if

    return daysDifference + 1
  end function

  private function customRoundUp(value as float) as integer
    integerPart = Int(value)

    if value - integerPart > 0
      roundedValue = integerPart + 1
    else
      roundedValue = integerPart
    end if

    return roundedValue
  end function

  private function selectProgram(programIndex)
    if m.channelFocused <> -1
      m.log.info("onProgramSelected", programIndex)
      channelItem = m.content.getChild(m.channelFocused)
      if channelItem <> invalid
        liveIndex = m.getLiveProgramIndexForChannel(channelItem)
        if programIndex = liveIndex
          program = channelItem.getChild(programIndex)
          if program <> invalid
            newEntry = m.parser.parseEntry(program)
            selection = m.createSelectionFromContent(newEntry)
            selection.playMode = "default"
            m.executeContentSelection(selection)
          end if
        end if
      end if
    end if
  end function

  private function onShowHideAnimation(anim as mv.animations.AnimationBase, visible as boolean, animated as boolean)
    m.log.info("onShowHideAnimation epg screen")

    if animated
      anim.start()
    else
      anim.jumpToEnd()
    end if
  end function

  private function isDayMenuInFocus(focusId)
    for i = 0 to m.focusIds[0].count() - 1
      if focusId = m.focusIds[0][0]
        return true
      end if
    end for
    return false
  end function

  private function createAnimations()
    'm.showAnim = new mv.animations.Move(m.backgroundDayRectangle, 0.1, [-700, 0], [0, 0])
    'm.hideAnim = new mv.animations.Move(m.backgroundDayRectangle, 0.3, [0, 0], [-700, 0])
  end function

  private function updateFocusControls()
    itemGroup = []
    if m.isUsingButtons
      itemGroup.push("menu")
      m.focusId = "menu"
      m.toggleNavigationMenuFocus()
    end if
    itemGroup.push("TimeGrid")
    m.focusIds.push(itemGroup)
  end function

  private function updateButtons(styles as mc.types.assocarray)
    m.setButtonStyles(styles)
  end function

  private function getLocalization()
    localization = asAA(m.riversJson.localizations)
    language = m.getInstance("languageCode") ?? "en"
    m.localizations = localization[language]
  end function

  private function createCustomItems()
    m.customItems = []
    dataTime = CreateObject("roDateTime")
    nowTime = dataTime.asSeconds()
    currentDayIndex = dataTime.getDayOfWeek()

    item = m.createButton("button_1", 0, 0) '//Today Item
    if item <> invalid
      m.customItems.push(item)
    end if

    'days = m.calculateDaysDifference(nowTime, m.programPlayStart)
    days = 8
    j = 1

    for i = currentDayIndex + 2 to days
      numberText = str(i).trim()
      item = m.createButton("button_" + numberText, i - 1, j)
      j++
      if item <> invalid
        m.customItems.push(item)
      end if
    end for

    for i = 2 to currentDayIndex
      numberText = str(i).trim()
      item = m.createButton("button_" + numberText, i - 1, j)
      j++
      if item <> invalid
        m.customItems.push(item)
      end if
    end for
  end function

  private function createButton(prefix, index, itemIndex)
    targetDay = m.calculateTargetDay(itemIndex)

    text = m.getLocalizeButtonText(prefix + "_title")
    text = zapp.viewUtils.textToTextTransformFormat(text, m.riversJsonData.styles.epg_filter_button_text_transform)

    if text <> invalid and text.trim() <> ""
      return {
        title: `${text}${targetDay}`
        index: index
      }
    end if

    return invalid
  end function

  private function calculateTargetDay(itemIndex)
    currentDateTime = CreateObject("roDateTime")

    currentYear = currentDateTime.GetYear()
    currentMonth = currentDateTime.GetMonth()

    daysInMonth = m.getDaysInMonth(currentMonth, currentYear)

    currentDay = currentDateTime.GetDayOfMonth()
    targetDay = int(currentDay + itemIndex)
    targetMonth = currentMonth
    targetYear = currentYear

    if targetDay > daysInMonth
      targetDay = targetDay - daysInMonth
      targetMonth = targetMonth + 1
      if targetMonth > 12
        targetMonth = 1
        targetYear = targetYear + 1
      end if
    end if

    targetDay = `, ${targetDay}`
    if itemIndex = 0
      targetDay = ""
    end if

    return targetDay
  end function

  function getDaysInMonth(month as integer, year as integer) as integer
    if month < 1 or month > 12
      return 0
    end if

    ' Days in each month (non-leap year)
    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    ' Adjust for leap year (February has 29 days)
    if m.isLeapYear(year) and month = 2
      return 29
    end if

    return daysInMonth[month]
  end function

  function isLeapYear(year)
    if (year mod 4 = 0 and year mod 100 <> 0) or (year mod 400 = 0)
      return true
    end if
    return false
  end function

  private function getLocalizeButtonText(prefix as string)
    if m.localizations <> invalid
      text = m.localizations[prefix]
      if text = invalid or text.trim() = ""
        text = m.riversJson.styles[prefix]
      end if
      return text
    end if
    return ""
  end function

  private function findLastIndexOf(stringToSearch as string, symbol as string) as integer
    lastIndex = -1
    for i = 0 to len(stringToSearch) - 1
      if mid(stringToSearch, i, 1) = symbol
        lastIndex = i
      end if
    end for
    return lastIndex
  end function

  private function updateMenuItems()
    m.log.info("updateMenuItems")

    items = []
    items.append(m.customItems)
    m.menuButtons = items
    m.jumpToIndex = 0
    m.buttonsIsReady = true
  end function

  private function toggleUpdateTimer(active as boolean)
    m.log.info("toggleUpdateTimer is active ", active)
    if active
      m.timeout = m.waitAFrame(m.loadChangedContentOnTimeReason, 60)
    else
      m.cancelWaitTimer(m.timeout)
    end if
  end function

  private function loadChangedContentOnTimeReason()
    m.loadChangedContent("showOnTimer")
    m.toggleUpdateTimer(true)
  end function

  private function loadChangedContent(reason as string) as boolean
    if m.content@.isReloadRequired(reason)
      m.load()
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
      return true
    else
      return false
    end if
  end function

  private function parseDateStringToSeconds(dateString)
    if type(dateString) <> "roString" and type(dateString) <> "String"
      m.log.error("parseDateStringToSeconds: not a valid string")
      return 0
    end if

    totalOffsetInSeconds = 0
    timeZone = dateString.right(6)
    if timeZone.startsWith("-") or timeZone.startsWith("+")
      offsetParts = timeZone.Split(":")
      hoursInSeconds = abs(mc.strToInt(offsetParts[0]) * 3600)
      minutesInSeconds = mc.strToInt(offsetParts[1]) * 60

      totalOffsetInSeconds = (hoursInSeconds + minutesInSeconds)
      if timeZone.startsWith("+")
        totalOffsetInSeconds *= -1
      end if

      dateString = dateString.replace(timeZone, "Z")
    end if

    if len(dateString) < 24 and len(dateString) > 25
      m.log.error("parseDateStringToSeconds: dateString is not in the expected format 'YYYY/MM/DD HH:MM:SS +zzzz'")
      return 0
    end if

    'Change to YYYY-MM-DD HH:MM:SS
    iso8601 = Left(dateString, 19)
    iso8601.replace("/", "-")
    zoneOffset = Right(dateString, 4)
    if zoneOffset.endsWith("Z")
      zoneOffsetHH = "0"
      zoneOffsetMM = "0"
    else
      zoneOffsetHH = Left(zoneOffset, 2)
      zoneOffsetMM = Right(zoneOffset, 2)
    end if
    zoneOffsetSign = 1

    if dateString.instr(20, "+") > 0
      zoneOffsetSign = -1
    end if

    parsedDate = CreateObject("roDateTime")
    parsedDate.FromISO8601String(iso8601)
    parsedSeconds = parsedDate.AsSeconds()

    ' return integer seconds in GMT
    result = parsedSeconds + zoneOffsetSign * ((zoneOffsetHH.ToInt() * 3600) + (zoneOffsetMM.ToInt() * 60))
    result += totalOffsetInSeconds
    return result
  end function

  private function substituteIdInUrl(url as string, channelItem, channelData, mapping, isoTime) as string
    matches = m.regex.matchAll(url)
    key = "id"
    value = ""

    if matches.count() > 0 and mapping.count() > 0
      for each match in matches
        key = match[1]
        if mapping[key].property <> invalid
          value = mc.getPath(channelData.json, mapping[key].property)
        else
          value = mc.getPath(channelData, key)
        end if
        url = url.replace(`{{${key}}}`, value)
      end for
    else
      value = mc.getPath(channelData, key)
      url = url.replace(`{{${key}}}`, value)
    end if

    channelItem.id = value

    lastSlashIndex = m.findLastIndexOf(url, "/")
    questionMarkIndex = url.Instr(lastSlashIndex, "?")

    if questionMarkIndex > 0
      concat = "&"
    else
      concat = "?"
    end if

    return `${url}${concat}start_time=${isoTime}`
  end function

  private function toggleNavigationMenuFocus()
    zapp.appService.toggleNavMenuFocus(true)
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Key Presses
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  override function onKeyPressUp() as boolean
    m.log.info("on Keypress up. focusId", m.focusId)
    if m.isDayMenuInFocus(m.focusId)
      m.toggleNavigationMenuFocus()
    end if

    if not m.isDayMenuInFocus(m.focusId)
      m.setFocusId(m.focusIds[0][0])
    end if
    return true
  end function

  function isCapturingAnyKeyPress(key as string, press as boolean) as boolean
    if key = "down" and m.focusId = "menu"
      if m.isUsingButtons
        m.setFocusId(m.focusIds[0][0])
      end if
    end if
    return false
  end function

  public function onKeyPressDown() as boolean
    m.log.info("onKeyPressDown", m.focusId)
    if m.isDayMenuInFocus(m.focusId)
      if m.isUsingButtons
        m.setFocusId(m.focusIds[0][1])
      else
        m.setFocusId(m.focusIds[0][0])
      end if
    end if

    return true
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ lifecycle
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  protected override function onShow() as void
    m.log.method("onShow", m.state)
    if m.state = "ready" or m.state = "initialized" or m.state = "error"
      if m.isFirstLoadComplete
        m.log.info("grid already loaded; code to manage reloadKey expiration is not yet implemented")

        'if m.loadChangedContent("showScreen")
        '  m.log.info("updating grid content")
        '  m.toggleUpdateTimer(true)
        'end if
        'm.removingGridGap()
        'm.load()
      else
        m.log.info("this zapp.view has never loaded - trying now")
        m.load()
      end if
    end if
    m.restoreSelection()
  end function

  function restoreSelection()
    if m.selection <> invalid and m.content <> invalid and m.content.count() > 0

    end if
  end function

  public override function cancelLoad()
    m.log.method("cancelLoad")

    super.cancelLoad()

    'if m.loadMoreTask <> invalid
    '  m.cancelTask(m.loadMoreTask)
    '  m.loadMoreTask = invalid
    '  m.state = "ready"
    'end if

    m.isShowingLoadingSpinner = false
  end function

  protected override function onHide()
    m.toggleUpdateTimer(false)
  end function

end class