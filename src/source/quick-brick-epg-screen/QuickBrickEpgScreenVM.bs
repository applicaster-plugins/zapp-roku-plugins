import "pkg:/source/authorization/BaseAuthPlugin.bs"
import "pkg:/source/authorization/JWTUtil.bs"
import "pkg:/source/lib/BaseClass.bs"
import "pkg:/source/lib/APIUtils.bs"
import "pkg:/source/UIBuilder/view/Component.bs"
import "pkg:/source/zapp-controls/BaseCollectionRowVM.bs"
import "pkg:/source/lib/ViewUtils.bs"
import "pkg:/source/zapp-pipes/EntryLoader.bs"
import "pkg:/source/UIBuilder/view/ScreenVM.bs"
import "pkg:/source/zapp-pipes/Parser.bs"

enum ButtonAction
  play = "play"
  info = "info"
  favorite = "favorite"
end enum

class QuickBrickEpgScreenVM extends zapp.uib.ScreenVM

  'styling
  public timeGridDayText = "Today"
  public filterLabelText = ""
  public menuButtons = []
  public titleTextStyle = {}
  public menuStyle = {}
  public menuPosition = [960, 584]
  public buttonSize = [700, 100]
  public buttonSpacing = 5
  public jumpToIndex = -1
  public isHeaderShown = false
  public isHeaderImageVisible = false
  public isHeaderImageVideoPlayback = false
  public isDetailsVisible = false
  public headerItem = invalid
  public headerStyle = invalid

  'public content = m.createSGNode("CollectionRow")
  public channelIndex = -1
  public programIndex = -1
  public channelFocused = 0
  public programFocused = 0
  public content = invalid
  public listStyle = {}
  public contentStartTime = {}
  public leftEdgeTargetTime = 0

  private jwtUtil = new zapp.JWTUtil()
  private dayInSeconds = 86400
  private canShowHeader = false
  private isHeaderUpdatingOnFocus = false
  private timeout = invalid
  private loadChannelTask = invalid
  private loadProgramTask = invalid
  private focusRectangle = invalid
  private channelItem = invalid
  private timeGridContent = invalid
  private timeGrid = invalid
  private contentLoader = new zapp.pipes.EntryLoader()

  private focusIds = []
  private riversJsonData = invalid
  private contentDepth = 1
  private taskCount = 0
  private programsData = []
  private channelCount = invalid
  private programPlayStart = 0
  private focusIndex = 0
  private localizations = invalid
  private isUsingButtons = true
  private cellStyle

  private showAnim
  private hideAnim

  private plugin

  @inject("channelGuideItem")
  private channelGuideItem

  @inject("constants")
  private constants

  @injectClass("zapp.PluginManager")
  private plugins

  private customItems = []

  ' /**
  '  * @module QuickBrickEpgScreenVM
  '  * @description
  ' **/
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Overridden Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function new(riversJson)
    super(riversJson, "QuickBrickEpgScreenVM")
    m.plugin = m.plugins.getPluginById("quick-brick-epg-screen")

    m.focusId = "TimeGrid"
    m.timeGrid = m.getMField("TimeGrid")

    m.style = m.getChildCellStyle(riversJson)
    m.riversJsonData = riversJson
    m.contentDepth = zapp.viewUtils.getUIBInt(riversJson.styles, "data_depth", 1)
    m.createAnimations()
    m.getLocalization()
    m.updateButtons(riversJson.styles)
  end function

  public override function load()
    m.log.info("load epg screen")

    m.makeEPGData(m.riversJsonData)
    m.epgHardcodedStyle(m.riversJsonData.styles)
    m.updateHeaderStyle(m.riversJsonData.styles)
    m.updateFocusControls()

    if m.isHeaderUpdatingOnFocus
      m.headerItem = invalid
      'm.observeNodeField(m.screenState, "focusedEntry", m.onFocusEntry)
    else
      m.headerItem = m.screenState.originEntry
      m.isHeaderShown = m.canShowHeader
    end if
    return true
  end function

  public override function resetStyles(riversJson)
    m.log.method("resetStyles")
    super.resetStyles(riversJson)
    m.setContentStyle(m.feed)

    m.feed = m.feed
    ' m.waitAFrame(m.onReloadStyle, 5)
  end function

  public override function onFocusEntry(entry) as void
    m.log.info("onFocusEntry epg screen")

    if m.isHeaderUpdatingOnFocus = true
      m.headerItem = entry
    end if
    m.isHeaderShown = m.canShowHeader
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Content creating
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function makeEPGData(riversJsonData)
    m.setEpgContent(riversJsonData.data)
    m.isFirstLoadComplete = true
    return true
  end function

  private function applyDataMap(feed as mc.types.node, style as mc.types.assocarray) as void
    m.log.info("applyDataMap epg screen")

    if style <> invalid

      if feed <> invalid
        dataSource = feed.getChild(0)
      else
        dataSource = invalid
      end if

      'm.applyDataMapToControls(style.dataMap, dataSource)
    end if

    if m.isFocused
      m.onGainedFocus(true)
    else
      m.focusRectangle.visible = false
    end if

  end function

  private function setEpgContent(data)
    m.log.info("setEpgContent")

    if asString(data.channels_source.source) <> ""
      m.state = "loading"
      m.loadChannelTask = m.executeloadTaskWithUrl("1", m.onLoadMoreResponse, data.channels_source.source, 0)
    end if
  end function

  private function loadMore()
    m.log.method("loadMore")
    m.state = "loading"
  end function

  private function onLoadMoreResponse(result)
    m.log.method("onLoadMoreResponse")

    if asBoolean(result.isOk)
      m.state = "ready"
      dataTime = CreateObject("roDateTime")
      parser = new zapp.pipes.Parser()
      milliseconds = dataTime.GetMilliseconds()
      isoTime = dataTime.ToISOString("millseconds").replace("Z", `.${milliseconds}Z`)
      m.timeGridContent = CreateObject("roSGNode", "ContentNode")
      m.taskCount = 0
      m.channelCount = -1
      channelsData = result.data
      programUrl = asString(m.riversJsonData.data.programs_source.source)
      if channelsData <> invalid
        for each channelData in channelsData.getChildren(-1, 0)
          m.channelItem = m.timeGridContent.createChild("ContentNode")
          m.channelItem.title = channelData.title
          if asArray(channelData.media_group).count() > 0
            m.channelItem.HDSMALLICONURL = parser.parseMediaGroup(m.channelItem, channelData.media_group)
          end if

          actuallUrl = m.substituteIdInUrl(programUrl, channelData.id, isoTime)
          m.taskCount++
          m.loadProgramTask = m.executeloadTaskWithUrl("1", m.onLoadProgramsResponse, actuallUrl, 0)
        end for
      end if
    else
      m.log.error("Failed to load channels data")
      m.state = "error"
    end if
  end function

  private function onLoadProgramsResponse(result)
    m.log.method("onLoadProgramsResponse")
    m.programsData = []
    if asBoolean(result.isOk)
      m.channelCount++
      programsData = result.data
      programsCount = programsData.getChildCount() - 1
      for each programData in programsData.getChildren(-1, 0)
        programItem = m.channelItem.createChild("ContentNode")
        programItem.PLAYSTART = m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programItem.PLAYDURATION = m.parseDateStringToSeconds(programData.json.extensions.end_time) - m.parseDateStringToSeconds(programData.json.extensions.start_time)
        programItem.TITLE = programData.title
        programItem.id = programData.id
        programItem.genre = asString(programData.json.genre)
        programItem.shortDescriptionLine1 = asString(programData.json.summary)
        'programItem.HDSMALLICONURL = programData.json.images.image_base
        m.programsData.push(programItem)
      end for
      if m.channelCount = 0 and programsCount > 0
        m.programPlayStart = m.programsData.[programsCount].PLAYSTART
      end if
    end if
    m.programsData.SortBy("PLAYSTART")
    m.timeGridContent.getChild(m.channelCount).appendChildren(m.programsData)
    m.taskCount--

    if m.taskCount = 0
      m.setField("content", m.timeGridContent)
      currentTime = CreateObject("roDateTime").asSeconds()
      m.contentStartTime = currentTime
      m.content = m.timeGridContent
      m.log.info("content for Epg", m.timeGridContent)
      m.state = "ready"
    end if

    m.createCustomItems()
    m.updateMenuItems()
  end function

  private function onLoadResponse(result)
    m.log.method("onLoadResponse")

    if asBoolean(result.isOk)
      m.content.appendChildren(result.data.getChildren(-1, 0))
    end if
    m.state = "ready"
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Public Method
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public function onProgramSelected(programIndex)
    m.log.info("onProgramSelected", programIndex)
    m.selectProgram(programIndex)
  end function

  public function onChannelFocused(channelIndex)
    m.log.info("onChannelFocused", channelIndex)
    m.channelFocused = channelIndex
  end function

  public function onProgramFocused(programIndex)
    m.log.info("onProgramFocused", programIndex)
    m.programFocused = programIndex
    'm.selectProgram(programIndex)
  end function

  public function onSelectedIndexChangeMenu(index)
    m.log.info("selected index", index)
    item = m.menuButtons[index]
    currentTime = CreateObject("roDateTime")
    currentDayIndex = currentTime.getDayOfWeek()

    if item <> invalid

      newIndex = item.index
      if index = 0
        dayDifference = 0
      else
        dayDifference = newIndex - currentDayIndex
      end if

      if dayDifference < 0
        dayDifference = abs(index - 7)
      end if

      targetTime = currentTime.asSeconds() + (m.dayInSeconds * dayDifference)

      m.leftEdgeTargetTime = targetTime
      m.content = m.timeGridContent
    end if
  end function

  function onLeftEdgeTargetTime()
    dt = CreateObject("roDateTime")
    nowTime = dt.AsSeconds()
    dayInSecond = m.dayInSeconds
    startDay = nowTime - (dt.GetHours() * 60 + dt.getMinutes() - dt.GetTimeZoneOffset()) * 60
    endDay = startDay + dayInSecond
    dt.FromSeconds(m.TimeGrid.leftEdgeTargetTime - (dt.GetTimeZoneOffset() * 60))
    m.timeGridDayText = dt.GetWeekday()
    if m.TimeGrid.leftEdgeTargetTime < endDay
      m.timeGridDayText = "Today"
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ style support
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function epgHardcodedStyle(style)
    m.log.info("set timeGrid style")

    plugin = m.plugin
    plugin.json.configuration_json.append(style)
    timeGrid = m.timeGrid
    timeGridGroup = m.getMField("TimeGridGroup")

    m.defaultValues(timeGrid, plugin, style)
    m.timeGridOverallSettings(timeGrid, timeGridGroup, plugin, style)
    m.programItemSection(timeGrid, plugin, style)
    m.timeBarSection(timeGrid, plugin, style)
    m.channelInfoSection(timeGrid, plugin, style)
    m.nowBarSection(timeGrid, plugin, style)
    m.nowNextSection(timeGrid, plugin, style)
  end function

  private function defaultValues(timeGrid, plugin, style)
    timeGrid.timeBarTwoLineLayout = true
    timeGrid.duration = 12600
    timeGrid.sectionDividerTopOffset = 30
    timeGrid.scrollSpeed = 100
    timeGrid.overlayBitmapUri = ""
    timeGrid.vertFocusAnimationStyle = "floatingFocus"
  end function

  private function timeGridOverallSettings(timeGrid, timeGridGroup, plugin, style)
    yPosition = plugin.getIntValue("time_grid_position_y", 500)
    xPosition = plugin.getIntValue("time_grid_margin_left", 0)
    rightOffset = plugin.getIntValue("time_grid_margin_right", 0)

    timeGridHeight = plugin.getIntValue("time_grid_item_size", 125)
    timeGrid.clippingRect = [0, -50, 1920, 1920]
    timeGridGroup.translation = [xPosition, yPosition]
    timeGrid.numRows = plugin.getIntValue("time_grid_visible_row", 6)
    timeGrid.itemSize = [1920 - rightOffset, timeGridHeight]
    timeGrid.focusBitmapUri = "pkg:/images/SearchFocusBackground2.9.png"
  end function

  private function programItemSection(timeGrid, plugin, style)
    programFontName = mc.getString(style, "label1_font_name", "medium")
    programFontSize = plugin.getIntValue("label1_font_size", 12)
    programRightPadding = plugin.getIntValue("grid_item_padding_right", 12)
    programLeftPadding = plugin.getIntValue("grid_item_padding_left", 12)

    timeGrid.programBackgroundBitmapUri = asString(style.guide_item_asset_background_uri, "pkg:/images/timeGridBackground.9.png")
    timeGrid.programTitleColor = zapp.viewUtils.transposeUIBColor(style.label1_live_font_color, "#FFFFFF")
    timeGrid.programTitleFocusedColor = zapp.viewUtils.transposeUIBColor(style.label1_live_focused_font_color, "#FFFFFF")
    timeGrid.programHorizMargin = programLeftPadding + programRightPadding
    timeGrid.programTitleFont = m.resolveFont(programFontName, programFontSize)
  end function

  private function timeBarSection(timeGrid, plugin, style)
    titleDayLabel = m.getMField("titleLabel")

    timeBarTopPadding = plugin.getIntValue("time_bar_padding_top", 60)
    timeBarBottomPadding = plugin.getIntValue("time_bar_padding_bottom", 60)
    timebarFontSize = plugin.getIntValue("time_bar_label_font_size", 12)
    timebarFontName = mc.getString(style, "time_bar_label_font_name", "medium")

    timeGrid.pastTimeScreenBlendColor = "#3D80FF"
    timeGrid.timeBarBitmapUri = asString(style.time_bar_background_url, ":")
    'timeGrid.timeBarHeight = timeBarBottomPadding + timeBarTopPadding
    timeGrid.timeLabelColor = zapp.viewUtils.transposeUIBColor(style.time_bar_label_font_color, "#FFFFFF")
    titleDayLabel.color = zapp.viewUtils.transposeUIBColor(style.time_bar_label_font_color, "#FFFFFF")
    titleDayLabel.font = m.resolveFont(timebarFontName, timebarFontSize)
    timeGrid.timeLabelFont = m.resolveFont(timebarFontName, timebarFontSize)
  end function

  private function resolveFont(programFontName, programFontSize)
    headerFont = CreateObject("roSGNode", "Font")
    font = invalid
    if programFontName <> invalid and programFontName.instr("SystemFont") <> -1
      font = "font:" + programFontName.trim()
    else if programFontName <> invalid and lCase(programFontName) = "medium" or lCase(programFontName) = "mediumbold"
      font = "font:" + programFontName.trim() + "SystemFont"
    else if programFontName <> invalid and programFontName.instr("SystemFont") = -1
      headerFont.uri = "pkg:/fonts/" + programFontName + ".ttf"
      headerFont.size = programFontSize
    else if programFontName <> invalid and font = invalid
      font = "font:" + programFontName.trim() + "SystemFont"
    else
      font = "font:MediumSystemFont"
    end if

    if font <> invalid
      return font
    else
      return headerFont
    end if
  end function

  private function channelInfoSection(timeGrid, plugin, style)
    channelAssetHeight = plugin.getIntValue("channel_asset_height", 42)
    channelPaddingTop = plugin.getIntValue("channel_padding_top", 15)
    channelPaddingRight = plugin.getIntValue("channel_padding_right", 13)
    channelPaddingBottom = plugin.getIntValue("channel_padding_bottom", 15)
    channelPaddingLeft = plugin.getIntValue("channel_padding_left", 13)

    m.channelGuideItem.channelGuideSettings = {
      "channelAssetHeight": channelAssetHeight
      "channelPaddingTop": channelPaddingTop
      "channelPaddingRight": channelPaddingRight
      "channelPaddingBottom": channelPaddingBottom
      "channelPaddingLeft": channelPaddingLeft
    }

    timeGrid.channelInfoBackgroundBitmapUri = asString(style.channel_background_item_uri, "pkg:/images/timeGridBackground.9.png")
    timeGrid.channelInfoWidth = plugin.getIntValue("channel_list_width", 245)
  end function

  private function nowBarSection(timeGrid, plugin, style)
    timeGrid.nowBarWidth = plugin.getIntValue("time_bar_badge_width", 10)
    timeGrid.nowBarBitmapUri = asString(style.time_bar_badge_item_uri)
    timeGrid.nowBarBlendColor = zapp.viewUtils.transposeUIBColor(style.time_bar_badge_background_color, "")
    timeGrid.nowBarOffset = plugin.getIntValue("time_bar_badge_padding_left", 0)
  end function

  private function nowNextSection(timeGrid, plugin, style)
    timeGrid.nowNextMode = asBoolean(style.grid_item_show)
    timeGrid.nowBackgroundBitmapUri = asString(style.grid_item_live_background_color, "pkg:/images/timeGridBackground.9.png")
    timeGrid.nextBackgroundBitmapUri = asString(style.grid_item_future_background_color, "pkg:/images/timeGridBackground.9.png")
    timeGrid.programNowNextTimeColor = zapp.viewUtils.transposeUIBColor(style.grid_item_future_background_color, "#FFFFFF")
    timeGrid.programNowNextTimeFocusedColor = zapp.viewUtils.transposeUIBColor(style.grid_item_future_focused_background_color, "#FFFFFF")
    'timeGrid.programNowNextHorizMargin =
    'timeGrid.programNowNextTimeTitleGap =
  end function

  private function updateHeaderStyle(styles)
    m.log.info("setHeroStyle")
    m.isHeaderShown = false
    m.canShowHeader = mc.getPath(styles, "header_is_shown", true)
    m.isHeaderUpdatingOnFocus = mc.getPath(styles, "header_update_on_focus", true)
    m.isDetailsVisible = m.canShowHeader and mc.getPath(styles, "header_text_is_shown", false)
    m.isHeaderImageVisible = m.canShowHeader and mc.getPath(styles, "header_image_is_shown", false)
    m.isHeaderImageVideoPlayback = mc.getPath(styles, "header_image_is_video_preview", true)
    'if m.isHeaderImageVideoPlayback
    '  m.getMField("contentGroup").videoTarget = m.getMField("headerControl").findNode("fadingBackgroundImage")
    'end if
    m.headerStyle = styles
  end function

  private function getChildCellStyle(componentJson as mc.types.assocarray)
    m.log.info("getChildCellStyle")

    cellStyles = m.getInstance("cellStyles")
    key = asString(componentJson.styles.cell_style_key)
    if cellStyles.styleIdsByKey.doesExist(key)
      cellKey = cellStyles.styleIdsByKey[key]
      return cellStyles[cellKey]
    end if
    return invalid
  end function

  private function setListStyle(content)
    m.log.method("setListStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      listStyle = zapp.collectionRowUtils.getRowListStyle(m.riversJson.styles, cellStyle.normal)
      listStyle.itemSize = listStyle.rowItemSize
      m.listStyle = listStyle
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if

  end function

  private function stylingChannelItemComponent(styles)
    channelPoster = invalid
    channelPoster.height = styles.channel_asset_height
    channelPoster.height = styles.channel_asset_height
    channelPoster.backgroundColor = zapp.viewUtils.transposeUIBColor(styles["channel_background_color"])
    translation = [abs(styles.channel_padding_left - styles.channel_padding_right), abs(styles.channel_padding_top - styles.channel_padding_bottom)]
    channelPoster.translation = translation
  end function

  private function stylingDayLabelComponent(styles)
    '// Will need to be implemented in the future scope
    localizedText = zapp.viewUtils.getLocalizedText("control", "localization")

    m.filterLabelText = "Filter Days"
    dayLabelText = zapp.viewUtils.textToTextTransformFormat(localizedText, styles.days_label_text_transform)
    dayLabelFont = zapp.viewUtils.makeUIBTextStyle(styles, "days_label")
    dayLabelSelected = zapp.viewUtils.makeUIBTextStyle(styles, "days_label_selected")

    marginStyle = zapp.viewUtils.makeUIBMargin(styles, "tv_buttons_container")

    marginTop = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_top")
    marginRight = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_right")
    marginBottom = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_bottom")
    marginLeft = zapp.viewUtils.getUIBInt(styles, "days_tabs_padding_left")

    m.listStyle = {
      translation: [abs(marginLeft - marginRight), abs(marginTop - marginBottom)]
      itemSpacing: [zapp.viewUtils.getUIBInt(styles, "days_tabs_horizontal_gutter", 15)]
      itemSize: zapp.viewUtils.makeUIBSize(styles, "item", 680, 80)
      vertFocusAnimationStyle: ""
      focusBitmapBlendColor: zapp.viewUtils.makeUIBTextStyle(styles, "days_label_focused")
      focusBitmapUri: zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    }
  end function

  private function stylingGridComponent(styles)
    grid = invalid
    grid.backgroundColor = zapp.viewUtils.transposeUIBColor(styles["days_tabs_background_color"])
    translation = [abs(styles.days_tabs_padding_left - styles.days_tabs_padding_right), abs(styles.days_tabs_padding_top - styles.days_tabs_padding_bottom)]
    grid.translation = translation
    grid.itemSpacings = [zapp.viewUtils.getUIBInt(styles, "grid_horizontal_gutter", 15)]
  end function

  private function setContentStyle(content)
    m.log.method("setContentStyle")

    if m.style <> invalid
      cellStyle = m.style.cell
      cellStyle.dataMap = m.style.dataMap
      cellStyle.delete("translation")
      mc.setOrAddNodeField(content, "_style", cellStyle)
      mc.setOrAddNodeField(content, "_styleId", m.style.id)
    end if
  end function

  private function setButtonStyles(styles)
    m.isUsingButtons = zapp.viewUtils.getUIBBool(styles, "epg_filter_button_enable")
    m.menuStyle = zapp.viewUtils.makeUIBButtonStyle(styles, "epg_filter_button", "custom", "")
    m.menuStyle.normal.delete("text")
    m.menuPosition = zapp.viewUtils.makeUIBPosition(styles, "epg_filter_button", 960, 200)
    m.buttonSize = zapp.viewUtils.makeUIBSize(styles, "epg_filter_button", 100, 100)
    m.buttonSpacing = zapp.viewUtils.getUIBInt(styles, "epg_filter_button_spacing", 5)
    mc.setOrAddNodeField(m.menuStyle, "layoutDirection", "horiz")
    m.titleTextStyle = zapp.viewUtils.makeUIBTextStyle(styles, "title")
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ feed processing
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  public override function onFeedResult(result)
    m.log.method("onFeedResult")
    m.toggleLoadingDataTask(false)

    if asBoolean(result.isOk)
      m.isFirstLoadComplete = true
      m.setContentStyle(result.data)
      m.feed = result.data
      m.restoreSelection()
      m.state = "ready"
      m.content.json = m.feed.json
      m.content.title = m.feed.title
      m.content.id = m.feed.id
      m.setContentStyle(m.content)
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
    else
      m.onFeedError(invalid)
      m.content@.receiveRowData([])
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Private Methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  private function calculateDaysDifference(currentTimestamp as integer, targetTimestamp as integer) as integer
    timestampDifference = targetTimestamp - currentTimestamp
    daysDifference = timestampDifference / m.dayInSeconds
    daysDifference = m.customRoundUp(daysDifference)

    if daysDifference >= 8
      return daysDifference
    end if

    return daysDifference + 1
  end function

  private function customRoundUp(value as float) as integer
    integerPart = Int(value)

    if value - integerPart > 0
      roundedValue = integerPart + 1
    else
      roundedValue = integerPart
    end if

    return roundedValue
  end function

  private function selectProgram(programIndex)
    if m.channelFocused <> -1
      m.log.info("onProgramSelected", programIndex)
      content = m.content.getChild(m.channelFocused)
      if content <> invalid
        program = content.getChild(programIndex)
        selection = m.createSelectionFromContent(program)
        selection.playMode = "default"
        mc.setOrAddNodeField(selection.initialItem, "itemType", "video")
        m.executeContentSelection(selection)
      end if
    end if
  end function

  private function onShowHideAnimation(anim as mv.animations.AnimationBase, visible as boolean, animated as boolean)
    m.log.info("onShowHideAnimation epg screen")

    if animated
      anim.start()
    else
      anim.jumpToEnd()
    end if
  end function

  private function isDayMenuInFocus(focusId)
    for i = 0 to m.focusIds[0].count() - 1
      if focusId = m.focusIds[0][0]
        return true
      end if
    end for
    return false
  end function

  private function createAnimations()
    'm.showAnim = new mv.animations.Move(m.backgroundDayRectangle, 0.1, [-700, 0], [0, 0])
    'm.hideAnim = new mv.animations.Move(m.backgroundDayRectangle, 0.3, [0, 0], [-700, 0])
  end function

  private function updateFocusControls()
    itemGroup = []
    if m.isUsingButtons
      itemGroup.push("menu")
    end if
    itemGroup.push("TimeGrid")
    m.focusIds.push(itemGroup)
  end function

  private function updateButtons(styles as mc.types.assocarray)
    m.setButtonStyles(styles)
  end function

  private function getLocalization()
    localization = asAA(m.plugin.json.configuration_json.localizations)
    language = m.getInstance("languageCode") ?? "en"
    m.localizations = localization[language]
  end function

  private function createCustomItems()
    m.customItems = []
    dataTime = CreateObject("roDateTime")
    nowTime = dataTime.asSeconds()
    currentDayIndex = dataTime.getDayOfWeek()

    item = m.createButton("button_1", 0, 0) '//Today Item
    if item <> invalid
      m.customItems.push(item)
    end if

    days = m.calculateDaysDifference(nowTime, m.programPlayStart)

    j = 1
    for i = currentDayIndex + 2 to days + currentDayIndex
      numberText = str(i).trim()
      item = m.createButton("button_" + numberText, i - 1, j)
      j++
      if item <> invalid
        m.customItems.push(item)
      end if
    end for
  end function

  private function createButton(prefix, index, itemIndex)
    targetDay = m.calculateTargetDay(itemIndex)

    text = m.getLocalizeButtonText(prefix + "_title")
    text = zapp.viewUtils.textToTextTransformFormat(text, m.riversJsonData.styles.epg_filter_button_text_transform)

    if text <> invalid and text.trim() <> ""
      return {
        title: `${text}${targetDay}`
        index: index
      }
    end if

    return invalid
  end function

  private function calculateTargetDay(itemIndex)
    currentDateTime = CreateObject("roDateTime")

    currentYear = currentDateTime.GetYear()
    currentMonth = currentDateTime.GetMonth()

    daysInMonth = m.getDaysInMonth(currentMonth, currentYear)

    currentDay = currentDateTime.GetDayOfMonth()
    targetDay = int(currentDay + itemIndex)
    targetMonth = currentMonth
    targetYear = currentYear

    if targetDay > daysInMonth
      targetDay = targetDay - daysInMonth
      targetMonth = targetMonth + 1
      if targetMonth > 12
        targetMonth = 1
        targetYear = targetYear + 1
      end if
    end if

    targetDay = `, ${targetDay}`
    if itemIndex = 0
      targetDay = ""
    end if

    return targetDay
  end function

  function getDaysInMonth(month as integer, year as integer) as integer
    if month < 1 or month > 12
      return 0
    end if

    ' Days in each month (non-leap year)
    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    ' Adjust for leap year (February has 29 days)
    if m.isLeapYear(year) and month = 2
      return 29
    end if

    return daysInMonth[month]
  end function

  function isLeapYear(year)
    if (year mod 4 = 0 and year mod 100 <> 0) or (year mod 400 = 0)
      return true
    end if
    return false
  end function

  private function getLocalizeButtonText(prefix as string)
    text = m.localizations[prefix]
    if text = invalid or text.trim() = ""
      text = m.riversJson.styles[prefix]
    end if
    return text
  end function

  private function updateMenuItems()
    m.log.info("updateMenuItems")

    items = []
    items.append(m.customItems)
    m.menuButtons = items
    m.jumpToIndex = 0
  end function

  private function toggleUpdateTimer(active as boolean)
    m.log.info("toggleUpdateTimer is active ", active)
    if active
      m.timeout = m.waitAFrame(m.loadChangedContentOnTimeReason, 60)
    else
      m.cancelWaitTimer(m.timeout)
    end if
  end function

  private function loadChangedContentOnTimeReason()
    m.loadChangedContent("showOnTimer")
    m.toggleUpdateTimer(true)
  end function

  private function loadChangedContent(reason as string) as boolean
    if m.content@.isReloadRequired(reason)
      m.load()
      m.content@.receiveRowData(m.feed.getChildren(-1, 0), true)
      return true
    else
      return false
    end if
  end function

  private function parseDateStringToSeconds(dateString)
    if type(dateString) <> "roString" and type(dateString) <> "String"
      m.log.error("parseDateStringToSeconds: not a valid string")
      return 0
    end if

    totalOffsetInSeconds = 0
    timeZone = dateString.right(6)
    if timeZone.startsWith("-") or timeZone.startsWith("+")
      offsetParts = timeZone.Split(":")
      hoursInSeconds = abs(mc.strToInt(offsetParts[0]) * 3600)
      minutesInSeconds = mc.strToInt(offsetParts[1]) * 60

      totalOffsetInSeconds = (hoursInSeconds + minutesInSeconds)
      if timeZone.startsWith("-")
        totalOffsetInSeconds *= -1
      end if

      dateString = dateString.replace(timeZone, "Z")
    end if

    if len(dateString) <> 24
      m.log.error("parseDateStringToSeconds: dateString is not in the expected format 'YYYY/MM/DD HH:MM:SS +zzzz'")
      return 0
    end if

    'Change to YYYY-MM-DD HH:MM:SS
    iso8601 = Left(dateString, 19)
    iso8601.replace("/", "-")
    zoneOffset = Right(dateString, 4)
    zoneOffsetHH = Left(zoneOffset, 2)
    zoneOffsetMM = Right(zoneOffset, 2)
    zoneOffsetSign = 1

    if dateString.instr(20, "+") > 0
      zoneOffsetSign = -1
    end if

    parsedDate = CreateObject("roDateTime")
    parsedDate.FromISO8601String(iso8601)
    parsedSeconds = parsedDate.AsSeconds()

    ' return integer seconds in GMT
    result = parsedSeconds + zoneOffsetSign * ((zoneOffsetHH.ToInt() * 3600) + (zoneOffsetMM.ToInt() * 60))
    result += totalOffsetInSeconds
    return result
  end function

  private function substituteIdInUrl(url as string, id as integer, isoTime) as string
    url = `${url}&start_time=${isoTime}`.replace("{{id}}", id)
    return url
  end function

  private function toggleNavigationMenuFocus()
    'zapp.appService.toggleNavMenuFocus(true)
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ Key Presses
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  override function onKeyPressUp() as boolean
    m.log.info("on Keypress up. focusId", m.focusId)
    if m.isDayMenuInFocus(m.focusId)
      m.toggleNavigationMenuFocus()
    end if

    if not m.isDayMenuInFocus(m.focusId)
      m.setFocusId(m.focusIds[0][0])
    end if
    return true
  end function

  public function onKeyPressDown() as boolean
    m.log.info("onKeyPressDown", m.focusId)
    if m.isDayMenuInFocus(m.focusId)
      if m.isUsingButtons
        m.setFocusId(m.focusIds[0][1])
      else
        m.setFocusId(m.focusIds[0][0])
      end if
    end if

    return true
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ lifecycle
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  protected override function onShow() as void
    m.log.method("onShow", m.state)
    if m.state = "ready" or m.state = "initialized" or m.state = "error"
      if m.isFirstLoadComplete
        m.log.info("grid already loaded; code to manage reloadKey expiration is not yet implemented")

        'if m.loadChangedContent("showScreen")
        '  m.log.info("updating grid content")
        '  m.toggleUpdateTimer(true)
        'end if
        'm.removingGridGap()
      else
        m.log.info("this zapp.view has never loaded - trying now")
        m.load()
      end if
    end if
    m.restoreSelection()
  end function

  function restoreSelection()
    if m.selection <> invalid and m.content <> invalid and m.content.count() > 0

    end if
  end function

  public override function cancelLoad()
    m.log.method("cancelLoad")

    super.cancelLoad()

    'if m.loadMoreTask <> invalid
    '  m.cancelTask(m.loadMoreTask)
    '  m.loadMoreTask = invalid
    '  m.state = "ready"
    'end if

    m.isShowingLoadingSpinner = false
  end function

  protected override function onHide()
    m.toggleUpdateTimer(false)
  end function

end class