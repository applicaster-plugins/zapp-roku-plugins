import "pkg:/source/video/analytics/XRayEventsFactory.bs"
import "pkg:/source/plugin-support/BasePlugin.bs"
import "pkg:/source/plugin-support/PluginManager.bs"
import "pkg:/source/video/analytics/AnalyticsEventInfo.bs"
import "pkg:/source/lib/APIUtils.bs"
import "pkg:/source/authorization/BaseAuthPlugin.bs"
import "pkg:/source/lib/URI.bs"
import "pkg:/source/video/Quantile.bs"

namespace zapp.video.analytics

  class XrayAudienceEvents extends zapp.BaseClass

    private eventFactory as zapp.video.analytics.XRayEventsFactory
    private enabled = false
    private eventURL = "https://track.applicaster.com/events/v1/"
    private contentNode = invalid
    private requestParams = []
    private userIdStorageKey = ""
    private eventBatch = 0
    private maxEventCount = invalid
    private executionTimer = invalid
    private isActive = false
    private listOfEvents = {}
    private pendingEvents = {}
    private enabledCrashLogs = false
    private crashEventsURL = "https://track.applicaster.com/crashes/v1/"

    @injectClass("zapp.URI")
    private uri

    function new()
      super("XrayAudienceEvents")
      pluginManager = new zapp.PluginManager()
      m.eventFactory = new zapp.video.analytics.XRayEventsFactory()
      m.maxEventCount = m.eventFactory.eventsByKey.count()
      'mioc.setInstance("eventBatch", 0)
      plugin = pluginManager.getPluginById("x-ray-audience-events")
      m.userIdStorageKey = plugin.getStringValue("user_identity_storage_key", "quick-brick-login-flow.access-token")
      m.enabled = plugin.getBoolValue("enabled")

      crashPlugin = pluginManager.getPluginById("xray_logging_plugin")
      m.enabledCrashLogs = crashPlugin.getBoolValue("crash_tracker_enabled")
      m.crashEventsURL = crashPlugin.getStringValue("crash_tracker_url", "https://track.applicaster.com/crashes/v1/")

      m.initialize()

      parts = m.userIdStorageKey.split(".")
      m.eventFactory.accountSection = asString(parts[0])
      m.eventFactory.accountKey = asString(parts[1])
    end function

    protected override function initialize()
      m.log.info("initialize eventFactory")
      m.eventFactory.initialize()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function sendAppLaunchedEvent()
      m.log.info("sending appLaunchedEvent")
      event = m.eventFactory.createEvent("app_launched")
      m.eventBatch = m.eventBatch + 1
      m.sendXrayAudienceEvents(event)
    end function

    function sendAppHomeLoaded(duration as integer)
      m.log.info("sending AppHomeLoaded event")
      event = m.eventFactory.createEvent("app_home_loaded", duration)
      m.eventBatch = m.eventBatch + 1
      m.sendXrayAudienceEvents(event)
    end function

    function sendAppPresentedEvent(duration as integer)
      m.log.info("sending appPresented event")
      event = m.eventFactory.createEvent("app_presented", duration)
      m.eventBatch = m.eventBatch + 1
      m.sendXrayAudienceEvents(event)
    end function

    function sendHookStartedEvent(hook as mc.types.assocarray)
      m.log.info("sending hookStarted event")
      event = m.eventFactory.createEvent("hook_started", invalid, hook)
      m.eventBatch = m.eventBatch + 1
      m.sendXrayAudienceEvents(event)
    end function

    function sendHookEndedEvent(duration as integer, hook as mc.types.assocarray)
      m.log.info("sending hookEnded event")
      event = m.eventFactory.createEvent("hook_ended", duration, hook)
      m.eventBatch = m.eventBatch + 1
      m.sendXrayAudienceEvents(event)
    end function

    private function createAndSendCrashEvent(crashType as string, params as mc.types.assocarray)
      event = m.eventFactory.createEvent(crashType, 0, invalid, params)
      m.sendXrayAudienceCrashEvents(event)
    end function

    function sendSoftCrashEvent(eventType as string, message as string)
      m.log.info("sending soft crash event")
      params = {
        event_type: eventType
        message: message
      }
      m.createAndSendCrashEvent("soft_crash", params)
    end function

    function sendHardCrashEvent(eventType = "" as string, message = "" as string)
      m.log.info("hard crash event triggered")
      launchArgs = m.getMField("top").getScene().launchArgs
      crashLogs = asString(launchArgs.crashLog)
      if crashLogs.len() > 0
        m.log.info("sending hard crash event with logs")
        params = {
          message: crashLogs.replace("\", "\\")
        }
        m.createAndSendCrashEvent("hard_crash", params)
      else if eventType.len() > 0 and message.len() > 0
        m.log.info("sending hard crash event with custom message")
        params = {
          event_type: eventType
          message: message
        }
        m.createAndSendCrashEvent("hard_crash", params)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function sendXrayAudienceCrashEvents(event)
      if m.enabledCrashLogs
        m.log.info("sendXrayAudienceCrashEvents with id ", event.id)
        listOfEvents = {
          "events": [
            event.properties
          ]
        }
        m.createTask("NetworkTask", {
          "url": m.crashEventsURL,
          "method": "POST",
          "headers": {
            "Content-type": "application/json",
            "accept": "application/json"
          },
          "params": listOfEvents
        })
      else
        m.log.info("XrayAudienceEvents crash logging is disabled.")
      end if
    end function

    private function sendXrayAudienceEvents(event)
      m.log.info("sendXrayAudienceEvents with id ", event.id)
      m.requestParams.push(event.properties)
      m.listOfEvents = {
        "events": m.requestParams
      }
      m.sendEventByTimerOrMaxEventCount()
    end function

    private function sendEventByTimerOrMaxEventCount()
      if m.eventBatch = m.maxEventCount
        m.executionEvents(m.listOfEvents)
        m.eventBatch = 0
      else
        if m.isActive = false
          original = m.listOfEvents
          m.pendingEvents = { events: [] }

          for each evt in original.events
            m.pendingEvents.events.push(evt)
          end for
          m.executionTimer = m.waitAFrame(m.executeEventByTimer, 5)
          m.isActive = true
        end if
      end if
    end function

    private function executeEventByTimer()
      m.executionEvents(m.pendingEvents)
    end function

    private function executionEvents(listOfEvents)
      m.log.info("sendXrayAudienceEvents with quantiti of ", m.eventBatch)
      m.createTask("NetworkTask", {
        "url": m.eventURL,
        "method": "POST",
        "headers": {
          "Content-type": "application/json",
          "accept": "application/json"
        },
        "params": listOfEvents
      })
      m.defaultValueAfterExecute()
    end function

    private function defaultValueAfterExecute()
      m.requestParams = []
      m.listOfEvents = {}
      m.isActive = false
    end function

  end class
end namespace